{
  "generatedAt": "2026-02-26T02:04:39.417Z",
  "totalSkills": 26,
  "sources": [
    {
      "name": "huggingface/skills",
      "url": "https://github.com/huggingface/skills"
    },
    {
      "name": "obra/superpowers",
      "url": "https://github.com/obra/superpowers"
    },
    {
      "name": "muratcankoylan/Agent-Skills-for-Context-Engineering",
      "url": "https://github.com/muratcankoylan/Agent-Skills-for-Context-Engineering"
    }
  ],
  "skills": [
    {
      "id": "obra-superpowers-brainstorming",
      "name": "brainstorming",
      "slug": "brainstorming",
      "description": "You MUST use this before any creative work - creating features, building components, adding functionality, or modifying behavior. Explores user intent, requirements and design before implementation.",
      "category": "Planning",
      "platform": "Superpowers",
      "platformIcon": "‚ö°",
      "source": "obra/superpowers",
      "sourceUrl": "https://github.com/obra/superpowers/tree/main/skills/brainstorming",
      "skillMdUrl": "https://raw.githubusercontent.com/obra/superpowers/main/skills/brainstorming/SKILL.md",
      "body": "# Brainstorming Ideas Into Designs\n\n## Overview\n\nHelp turn ideas into fully formed designs and specs through natural collaborative dialogue.\n\nStart by understanding the current project context, then ask questions one at a time to refine the idea. Once you understand what you're building, present the design and get user approval.\n\n<HARD-GATE>\nDo NOT invoke any implementation skill, write any code, scaffold any project, or take any implementation action until you have presented a design and the user has approved it. This applies to EVERY project regardless of perceived simplicity.\n</HARD-GATE>\n\n## Anti-Pattern: \"This Is Too Simple To Need A Design\"\n\nEvery project goes through this process. A todo list, a single-function utility, a config change ‚Äî all of them. \"Simple\" projects are where unexamined assumptions cause the most wasted work. The design can be short (a few sentences for truly simple projects), but you MUST present it and get approval.\n\n## Checklist\n\nYou MUST create a task for each of these items and complete them in order:\n\n1. **Explore project context** ‚Äî check files, docs, recent commits\n2. **Ask clarifying questions** ‚Äî one at a time, understand purpose/constraints/success criteria\n3. **Propose 2-3 approaches** ‚Äî with trade-offs and your recommendation\n4. **Present design** ‚Äî in sections scaled to their complexity, get user approval after each section\n5. **Write design doc** ‚Äî save to `docs/plans/YYYY-MM-DD-<topic>-design.md` and commit\n6. **Transition to implementation** ‚Äî invoke writing-plans skill to create implementation plan\n\n## Process Flow\n\n```dot\ndigraph brainstorming {\n    \"Explore project context\" [shape=box];\n    \"Ask clarifying questions\" [shape=box];\n    \"Propose 2-3 approaches\" [shape=box];\n    \"Present design sections\" [shape=box];\n    \"User approves design?\" [shape=diamond];\n    \"Write design doc\" [shape=box];\n    \"Invoke writing-plans skill\" [shape=doublecircle];\n\n    \"Explore project context\" -> \"Ask clarifying questions\";\n    \"Ask clarifying questions\" -> \"Propose 2-3 approaches\";\n    \"Propose 2-3 approaches\" -> \"Present design sections\";\n    \"Present design sections\" -> \"User approves design?\";\n    \"User approves design?\" -> \"Present design sections\" [label=\"no, revise\"];\n    \"User approves design?\" -> \"Write design doc\" [label=\"yes\"];\n    \"Write design doc\" -> \"Invoke writing-plans skill\";\n}\n```\n\n**The terminal state is invoking writing-plans.** Do NOT invoke frontend-design, mcp-builder, or any other implementation skill. The ONLY skill you invoke after brainstorming is writing-plans.\n\n## The Process\n\n**Understanding the idea:**\n- Check out the current project state first (files, docs, recent commits)\n- Ask questions one at a time to refine the idea\n- Prefer multiple choice questions when possible, but open-ended is fine too\n- Only one question per message - if a topic needs more exploration, break it into multiple questions\n- Focus on understanding: purpose, constraints, success criteria\n\n**Exploring approaches:**\n- Propose 2-3 different approaches with trade-offs\n- Present options conversationally with your recommendation and reasoning\n- Lead with your recommended option and explain why\n\n**Presenting the design:**\n- Once you believe you understand what you're building, present the design\n- Scale each section to its complexity: a few sentences if straightforward, up to 200-300 words if nuanced\n- Ask after each section whether it looks right so far\n- Cover: architecture, components, data flow, error handling, testing\n- Be ready to go back and clarify if something doesn't make sense\n\n## After the Design\n\n**Documentation:**\n- Write the validated design to `docs/plans/YYYY-MM-DD-<topic>-design.md`\n- Use elements-of-style:writing-clearly-and-concisely skill if available\n- Commit the design document to git\n\n**Implementation:**\n- Invoke the writing-plans skill to create a detailed implementation plan\n- Do NOT invoke any other skill. writing-plans is the next step.\n\n## Key Principles\n\n- **One question at a time** - Don't overwhelm with multiple questions\n- **Multiple choice preferred** - Easier to answer than open-ended when possible\n- **YAGNI ruthlessly** - Remove unnecessary features from all designs\n- **Explore alternatives** - Always propose 2-3 approaches before settling\n- **Incremental validation** - Present design, get approval before moving on\n- **Be flexible** - Go back and clarify when something doesn't make sense"
    },
    {
      "id": "obra-superpowers-dispatching-parallel-agents",
      "name": "dispatching-parallel-agents",
      "slug": "dispatching-parallel-agents",
      "description": "Use when facing 2+ independent tasks that can be worked on without shared state or sequential dependencies",
      "category": "DevOps",
      "platform": "Superpowers",
      "platformIcon": "‚ö°",
      "source": "obra/superpowers",
      "sourceUrl": "https://github.com/obra/superpowers/tree/main/skills/dispatching-parallel-agents",
      "skillMdUrl": "https://raw.githubusercontent.com/obra/superpowers/main/skills/dispatching-parallel-agents/SKILL.md",
      "body": "# Dispatching Parallel Agents\n\n## Overview\n\nWhen you have multiple unrelated failures (different test files, different subsystems, different bugs), investigating them sequentially wastes time. Each investigation is independent and can happen in parallel.\n\n**Core principle:** Dispatch one agent per independent problem domain. Let them work concurrently.\n\n## When to Use\n\n```dot\ndigraph when_to_use {\n    \"Multiple failures?\" [shape=diamond];\n    \"Are they independent?\" [shape=diamond];\n    \"Single agent investigates all\" [shape=box];\n    \"One agent per problem domain\" [shape=box];\n    \"Can they work in parallel?\" [shape=diamond];\n    \"Sequential agents\" [shape=box];\n    \"Parallel dispatch\" [shape=box];\n\n    \"Multiple failures?\" -> \"Are they independent?\" [label=\"yes\"];\n    \"Are they independent?\" -> \"Single agent investigates all\" [label=\"no - related\"];\n    \"Are they independent?\" -> \"Can they work in parallel?\" [label=\"yes\"];\n    \"Can they work in parallel?\" -> \"Parallel dispatch\" [label=\"yes\"];\n    \"Can they work in parallel?\" -> \"Sequential agents\" [label=\"no - shared state\"];\n}\n```\n\n**Use when:**\n- 3+ test files failing with different root causes\n- Multiple subsystems broken independently\n- Each problem can be understood without context from others\n- No shared state between investigations\n\n**Don't use when:**\n- Failures are related (fix one might fix others)\n- Need to understand full system state\n- Agents would interfere with each other\n\n## The Pattern\n\n### 1. Identify Independent Domains\n\nGroup failures by what's broken:\n- File A tests: Tool approval flow\n- File B tests: Batch completion behavior\n- File C tests: Abort functionality\n\nEach domain is independent - fixing tool approval doesn't affect abort tests.\n\n### 2. Create Focused Agent Tasks\n\nEach agent gets:\n- **Specific scope:** One test file or subsystem\n- **Clear goal:** Make these tests pass\n- **Constraints:** Don't change other code\n- **Expected output:** Summary of what you found and fixed\n\n### 3. Dispatch in Parallel\n\n```typescript\n// In Claude Code / AI environment\nTask(\"Fix agent-tool-abort.test.ts failures\")\nTask(\"Fix batch-completion-behavior.test.ts failures\")\nTask(\"Fix tool-approval-race-conditions.test.ts failures\")\n// All three run concurrently\n```\n\n### 4. Review and Integrate\n\nWhen agents return:\n- Read each summary\n- Verify fixes don't conflict\n- Run full test suite\n- Integrate all changes\n\n## Agent Prompt Structure\n\nGood agent prompts are:\n1. **Focused** - One clear problem domain\n2. **Self-contained** - All context needed to understand the problem\n3. **Specific about output** - What should the agent return?\n\n```markdown\nFix the 3 failing tests in src/agents/agent-tool-abort.test.ts:\n\n1. \"should abort tool with partial output capture\" - expects 'interrupted at' in message\n2. \"should handle mixed completed and aborted tools\" - fast tool aborted instead of completed\n3. \"should properly track pendingToolCount\" - expects 3 results but gets 0\n\nThese are timing/race condition issues. Your task:\n\n1. Read the test file and understand what each test verifies\n2. Identify root cause - timing issues or actual bugs?\n3. Fix by:\n   - Replacing arbitrary timeouts with event-based waiting\n   - Fixing bugs in abort implementation if found\n   - Adjusting test expectations if testing changed behavior\n\nDo NOT just increase timeouts - find the real issue.\n\nReturn: Summary of what you found and what you fixed.\n```\n\n## Common Mistakes\n\n**‚ùå Too broad:** \"Fix all the tests\" - agent gets lost\n**‚úÖ Specific:** \"Fix agent-tool-abort.test.ts\" - focused scope\n\n**‚ùå No context:** \"Fix the race condition\" - agent doesn't know where\n**‚úÖ Context:** Paste the error messages and test names\n\n**‚ùå No constraints:** Agent might refactor everything\n**‚úÖ Constraints:** \"Do NOT change production code\" or \"Fix tests only\"\n\n**‚ùå Vague output:** \"Fix it\" - you don't know what changed\n**‚úÖ Specific:** \"Return summary of root cause and changes\"\n\n## When NOT to Use\n\n**Related failures:** Fixing one might fix others - investigate together first\n**Need full context:** Understanding requires seeing entire system\n**Exploratory debugging:** You don't know what's broken yet\n**Shared state:** Agents would interfere (editing same files, using same resources)\n\n## Real Example from Session\n\n**Scenario:** 6 test failures across 3 files after major refactoring\n\n**Failures:**\n- agent-tool-abort.test.ts: 3 failures (timing issues)\n- batch-completion-behavior.test.ts: 2 failures (tools not executing)\n- tool-approval-race-conditions.test.ts: 1 failure (execution count = 0)\n\n**Decision:** Independent domains - abort logic separate from batch completion separate from race conditions\n\n**Dispatch:**\n```\nAgent 1 ‚Üí Fix agent-tool-abort.test.ts\nAgent 2 ‚Üí Fix batch-completion-behavior.test.ts\nAgent 3 ‚Üí Fix tool-approval-race-conditions.test.ts\n```\n\n**Results:**\n- Agent 1: Replaced timeouts with event-based waiting\n- Agent 2: Fixed event structure bug (threadId in wrong place)\n- Agent 3: Added wait for async tool execution to complete\n\n**Integration:** All fixes independent, no conflicts, full suite green\n\n**Time saved:** 3 problems solved in parallel vs sequentially\n\n## Key Benefits\n\n1. **Parallelization** - Multiple investigations happen simultaneously\n2. **Focus** - Each agent has narrow scope, less context to track\n3. **Independence** - Agents don't interfere with each other\n4. **Speed** - 3 problems solved in time of 1\n\n## Verification\n\nAfter agents return:\n1. **Review each summary** - Understand what changed\n2. **Check for conflicts** - Did agents edit same code?\n3. **Run full suite** - Verify all fixes work together\n4. **Spot check** - Agents can make systematic errors\n\n## Real-World Impact\n\nFrom debugging session (2025-10-03):\n- 6 failures across 3 files\n- 3 agents dispatched in parallel\n- All investigations completed concurrently\n- All fixes integrated successfully\n- Zero conflicts between agent changes"
    },
    {
      "id": "obra-superpowers-executing-plans",
      "name": "executing-plans",
      "slug": "executing-plans",
      "description": "Use when you have a written implementation plan to execute in a separate session with review checkpoints",
      "category": "Quality",
      "platform": "Superpowers",
      "platformIcon": "‚ö°",
      "source": "obra/superpowers",
      "sourceUrl": "https://github.com/obra/superpowers/tree/main/skills/executing-plans",
      "skillMdUrl": "https://raw.githubusercontent.com/obra/superpowers/main/skills/executing-plans/SKILL.md",
      "body": "# Executing Plans\n\n## Overview\n\nLoad plan, review critically, execute tasks in batches, report for review between batches.\n\n**Core principle:** Batch execution with checkpoints for architect review.\n\n**Announce at start:** \"I'm using the executing-plans skill to implement this plan.\"\n\n## The Process\n\n### Step 1: Load and Review Plan\n1. Read plan file\n2. Review critically - identify any questions or concerns about the plan\n3. If concerns: Raise them with your human partner before starting\n4. If no concerns: Create TodoWrite and proceed\n\n### Step 2: Execute Batch\n**Default: First 3 tasks**\n\nFor each task:\n1. Mark as in_progress\n2. Follow each step exactly (plan has bite-sized steps)\n3. Run verifications as specified\n4. Mark as completed\n\n### Step 3: Report\nWhen batch complete:\n- Show what was implemented\n- Show verification output\n- Say: \"Ready for feedback.\"\n\n### Step 4: Continue\nBased on feedback:\n- Apply changes if needed\n- Execute next batch\n- Repeat until complete\n\n### Step 5: Complete Development\n\nAfter all tasks complete and verified:\n- Announce: \"I'm using the finishing-a-development-branch skill to complete this work.\"\n- **REQUIRED SUB-SKILL:** Use superpowers:finishing-a-development-branch\n- Follow that skill to verify tests, present options, execute choice\n\n## When to Stop and Ask for Help\n\n**STOP executing immediately when:**\n- Hit a blocker mid-batch (missing dependency, test fails, instruction unclear)\n- Plan has critical gaps preventing starting\n- You don't understand an instruction\n- Verification fails repeatedly\n\n**Ask for clarification rather than guessing.**\n\n## When to Revisit Earlier Steps\n\n**Return to Review (Step 1) when:**\n- Partner updates the plan based on your feedback\n- Fundamental approach needs rethinking\n\n**Don't force through blockers** - stop and ask.\n\n## Remember\n- Review plan critically first\n- Follow plan steps exactly\n- Don't skip verifications\n- Reference skills when plan says to\n- Between batches: just report and wait\n- Stop when blocked, don't guess\n- Never start implementation on main/master branch without explicit user consent\n\n## Integration\n\n**Required workflow skills:**\n- **superpowers:using-git-worktrees** - REQUIRED: Set up isolated workspace before starting\n- **superpowers:writing-plans** - Creates the plan this skill executes\n- **superpowers:finishing-a-development-branch** - Complete development after all tasks"
    },
    {
      "id": "obra-superpowers-finishing-a-development-branch",
      "name": "finishing-a-development-branch",
      "slug": "finishing-a-development-branch",
      "description": "Use when implementation is complete, all tests pass, and you need to decide how to integrate the work - guides completion of development work by presenting structured options for merge, PR, or cleanup",
      "category": "Quality",
      "platform": "Superpowers",
      "platformIcon": "‚ö°",
      "source": "obra/superpowers",
      "sourceUrl": "https://github.com/obra/superpowers/tree/main/skills/finishing-a-development-branch",
      "skillMdUrl": "https://raw.githubusercontent.com/obra/superpowers/main/skills/finishing-a-development-branch/SKILL.md",
      "body": "# Finishing a Development Branch\n\n## Overview\n\nGuide completion of development work by presenting clear options and handling chosen workflow.\n\n**Core principle:** Verify tests ‚Üí Present options ‚Üí Execute choice ‚Üí Clean up.\n\n**Announce at start:** \"I'm using the finishing-a-development-branch skill to complete this work.\"\n\n## The Process\n\n### Step 1: Verify Tests\n\n**Before presenting options, verify tests pass:**\n\n```bash\n# Run project's test suite\nnpm test / cargo test / pytest / go test ./...\n```\n\n**If tests fail:**\n```\nTests failing (<N> failures). Must fix before completing:\n\n[Show failures]\n\nCannot proceed with merge/PR until tests pass.\n```\n\nStop. Don't proceed to Step 2.\n\n**If tests pass:** Continue to Step 2.\n\n### Step 2: Determine Base Branch\n\n```bash\n# Try common base branches\ngit merge-base HEAD main 2>/dev/null || git merge-base HEAD master 2>/dev/null\n```\n\nOr ask: \"This branch split from main - is that correct?\"\n\n### Step 3: Present Options\n\nPresent exactly these 4 options:\n\n```\nImplementation complete. What would you like to do?\n\n1. Merge back to <base-branch> locally\n2. Push and create a Pull Request\n3. Keep the branch as-is (I'll handle it later)\n4. Discard this work\n\nWhich option?\n```\n\n**Don't add explanation** - keep options concise.\n\n### Step 4: Execute Choice\n\n#### Option 1: Merge Locally\n\n```bash\n# Switch to base branch\ngit checkout <base-branch>\n\n# Pull latest\ngit pull\n\n# Merge feature branch\ngit merge <feature-branch>\n\n# Verify tests on merged result\n<test command>\n\n# If tests pass\ngit branch -d <feature-branch>\n```\n\nThen: Cleanup worktree (Step 5)\n\n#### Option 2: Push and Create PR\n\n```bash\n# Push branch\ngit push -u origin <feature-branch>\n\n# Create PR\ngh pr create --title \"<title>\" --body \"$(cat <<'EOF'\n## Summary\n<2-3 bullets of what changed>\n\n## Test Plan\n- [ ] <verification steps>\nEOF\n)\"\n```\n\nThen: Cleanup worktree (Step 5)\n\n#### Option 3: Keep As-Is\n\nReport: \"Keeping branch <name>. Worktree preserved at <path>.\"\n\n**Don't cleanup worktree.**\n\n#### Option 4: Discard\n\n**Confirm first:**\n```\nThis will permanently delete:\n- Branch <name>\n- All commits: <commit-list>\n- Worktree at <path>\n\nType 'discard' to confirm.\n```\n\nWait for exact confirmation.\n\nIf confirmed:\n```bash\ngit checkout <base-branch>\ngit branch -D <feature-branch>\n```\n\nThen: Cleanup worktree (Step 5)\n\n### Step 5: Cleanup Worktree\n\n**For Options 1, 2, 4:**\n\nCheck if in worktree:\n```bash\ngit worktree list | grep $(git branch --show-current)\n```\n\nIf yes:\n```bash\ngit worktree remove <worktree-path>\n```\n\n**For Option 3:** Keep worktree.\n\n## Quick Reference\n\n| Option | Merge | Push | Keep Worktree | Cleanup Branch |\n|--------|-------|------|---------------|----------------|\n| 1. Merge locally | ‚úì | - | - | ‚úì |\n| 2. Create PR | - | ‚úì | ‚úì | - |\n| 3. Keep as-is | - | - | ‚úì | - |\n| 4. Discard | - | - | - | ‚úì (force) |\n\n## Common Mistakes\n\n**Skipping test verification**\n- **Problem:** Merge broken code, create failing PR\n- **Fix:** Always verify tests before offering options\n\n**Open-ended questions**\n- **Problem:** \"What should I do next?\" ‚Üí ambiguous\n- **Fix:** Present exactly 4 structured options\n\n**Automatic worktree cleanup**\n- **Problem:** Remove worktree when might need it (Option 2, 3)\n- **Fix:** Only cleanup for Options 1 and 4\n\n**No confirmation for discard**\n- **Problem:** Accidentally delete work\n- **Fix:** Require typed \"discard\" confirmation\n\n## Red Flags\n\n**Never:**\n- Proceed with failing tests\n- Merge without verifying tests on result\n- Delete work without confirmation\n- Force-push without explicit request\n\n**Always:**\n- Verify tests before offering options\n- Present exactly 4 options\n- Get typed confirmation for Option 4\n- Clean up worktree for Options 1 & 4 only\n\n## Integration\n\n**Called by:**\n- **subagent-driven-development** (Step 7) - After all tasks complete\n- **executing-plans** (Step 5) - After all batches complete\n\n**Pairs with:**\n- **using-git-worktrees** - Cleans up worktree created by that skill"
    },
    {
      "id": "huggingface-skills-huggingface-gradio",
      "name": "gradio",
      "slug": "huggingface-gradio",
      "description": "Build Gradio web UIs and demos in Python. Use when creating or editing Gradio apps, components, event listeners, layouts, or chatbots.",
      "category": "Development",
      "platform": "HuggingFace",
      "platformIcon": "ü§ó",
      "source": "huggingface/skills",
      "sourceUrl": "https://github.com/huggingface/skills/tree/main/skills/huggingface-gradio",
      "skillMdUrl": "https://raw.githubusercontent.com/huggingface/skills/main/skills/huggingface-gradio/SKILL.md",
      "body": "# Gradio\n\nGradio is a Python library for building interactive web UIs and ML demos. This skill covers the core API, patterns, and examples.\n\n## Guides\n\nDetailed guides on specific topics (read these when relevant):\n\n- [Quickstart](https://www.gradio.app/guides/quickstart)\n- [The Interface Class](https://www.gradio.app/guides/the-interface-class)\n- [Blocks and Event Listeners](https://www.gradio.app/guides/blocks-and-event-listeners)\n- [Controlling Layout](https://www.gradio.app/guides/controlling-layout)\n- [More Blocks Features](https://www.gradio.app/guides/more-blocks-features)\n- [Custom CSS and JS](https://www.gradio.app/guides/custom-CSS-and-JS)\n- [Streaming Outputs](https://www.gradio.app/guides/streaming-outputs)\n- [Streaming Inputs](https://www.gradio.app/guides/streaming-inputs)\n- [Sharing Your App](https://www.gradio.app/guides/sharing-your-app)\n- [Custom HTML Components](https://www.gradio.app/guides/custom-HTML-components)\n- [Getting Started with the Python Client](https://www.gradio.app/guides/getting-started-with-the-python-client)\n- [Getting Started with the JS Client](https://www.gradio.app/guides/getting-started-with-the-js-client)\n\n## Core Patterns\n\n**Interface** (high-level): wraps a function with input/output components.\n\n```python\nimport gradio as gr\n\ndef greet(name):\n    return f\"Hello {name}!\"\n\ngr.Interface(fn=greet, inputs=\"text\", outputs=\"text\").launch()\n```\n\n**Blocks** (low-level): flexible layout with explicit event wiring.\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    name = gr.Textbox(label=\"Name\")\n    output = gr.Textbox(label=\"Greeting\")\n    btn = gr.Button(\"Greet\")\n    btn.click(fn=lambda n: f\"Hello {n}!\", inputs=name, outputs=output)\n\ndemo.launch()\n```\n\n**ChatInterface**: high-level wrapper for chatbot UIs.\n\n```python\nimport gradio as gr\n\ndef respond(message, history):\n    return f\"You said: {message}\"\n\ngr.ChatInterface(fn=respond).launch()\n```\n\n## Key Component Signatures\n\n### `Textbox(value: str | I18nData | Callable | None = None, type: Literal['text', 'password', 'email'] = \"text\", lines: int = 1, max_lines: int | None = None, placeholder: str | I18nData | None = None, label: str | I18nData | None = None, info: str | I18nData | None = None, every: Timer | float | None = None, inputs: Component | Sequence[Component] | set[Component] | None = None, show_label: bool | None = None, container: bool = True, scale: int | None = None, min_width: int = 160, interactive: bool | None = None, visible: bool | Literal['hidden'] = True, elem_id: str | None = None, autofocus: bool = False, autoscroll: bool = True, elem_classes: list[str] | str | None = None, render: bool = True, key: int | str | tuple[int | str, ...] | None = None, preserved_by_key: list[str] | str | None = \"value\", text_align: Literal['left', 'right'] | None = None, rtl: bool = False, buttons: list[Literal['copy'] | Button] | None = None, max_length: int | None = None, submit_btn: str | bool | None = False, stop_btn: str | bool | None = False, html_attributes: InputHTMLAttributes | None = None)`\nCreates a textarea for user to enter string input or display string output..\n\n### `Number(value: float | Callable | None = None, label: str | I18nData | None = None, placeholder: str | I18nData | None = None, info: str | I18nData | None = None, every: Timer | float | None = None, inputs: Component | Sequence[Component] | set[Component] | None = None, show_label: bool | None = None, container: bool = True, scale: int | None = None, min_width: int = 160, interactive: bool | None = None, visible: bool | Literal['hidden'] = True, elem_id: str | None = None, elem_classes: list[str] | str | None = None, render: bool = True, key: int | str | tuple[int | str, ...] | None = None, preserved_by_key: list[str] | str | None = \"value\", buttons: list[Button] | None = None, precision: int | None = None, minimum: float | None = None, maximum: float | None = None, step: float = 1)`\nCreates a numeric field for user to enter numbers as input or display numeric output..\n\n### `Slider(minimum: float = 0, maximum: float = 100, value: float | Callable | None = None, step: float | None = None, precision: int | None = None, label: str | I18nData | None = None, info: str | I18nData | None = None, every: Timer | float | None = None, inputs: Component | Sequence[Component] | set[Component] | None = None, show_label: bool | None = None, container: bool = True, scale: int | None = None, min_width: int = 160, interactive: bool | None = None, visible: bool | Literal['hidden'] = True, elem_id: str | None = None, elem_classes: list[str] | str | None = None, render: bool = True, key: int | str | tuple[int | str, ...] | None = None, preserved_by_key: list[str] | str | None = \"value\", randomize: bool = False, buttons: list[Literal['reset']] | None = None)`\nCreates a slider that ranges from {minimum} to {maximum} with a step size of {step}..\n\n### `Checkbox(value: bool | Callable = False, label: str | I18nData | None = None, info: str | I18nData | None = None, every: Timer | float | None = None, inputs: Component | Sequence[Component] | set[Component] | None = None, show_label: bool | None = None, container: bool = True, scale: int | None = None, min_width: int = 160, interactive: bool | None = None, visible: bool | Literal['hidden'] = True, elem_id: str | None = None, elem_classes: list[str] | str | None = None, render: bool = True, key: int | str | tuple[int | str, ...] | None = None, preserved_by_key: list[str] | str | None = \"value\", buttons: list[Button] | None = None)`\nCreates a checkbox that can be set to `True` or `False`.\n\n### `Dropdown(choices: Sequence[str | int | float | tuple[str, str | int | float]] | None = None, value: str | int | float | Sequence[str | int | float] | Callable | DefaultValue | None = DefaultValue(), type: Literal['value', 'index'] = \"value\", multiselect: bool | None = None, allow_custom_value: bool = False, max_choices: int | None = None, filterable: bool = True, label: str | I18nData | None = None, info: str | I18nData | None = None, every: Timer | float | None = None, inputs: Component | Sequence[Component] | set[Component] | None = None, show_label: bool | None = None, container: bool = True, scale: int | None = None, min_width: int = 160, interactive: bool | None = None, visible: bool | Literal['hidden'] = True, elem_id: str | None = None, elem_classes: list[str] | str | None = None, render: bool = True, key: int | str | tuple[int | str, ...] | None = None, preserved_by_key: list[str] | str | None = \"value\", buttons: list[Button] | None = None)`\nCreates a dropdown of choices from which a single entry or multiple entries can be selected (as an input component) or displayed (as an output component)..\n\n### `Radio(choices: Sequence[str | int | float | tuple[str, str | int | float]] | None = None, value: str | int | float | Callable | None = None, type: Literal['value', 'index'] = \"value\", label: str | I18nData | None = None, info: str | I18nData | None = None, every: Timer | float | None = None, inputs: Component | Sequence[Component] | set[Component] | None = None, show_label: bool | None = None, container: bool = True, scale: int | None = None, min_width: int = 160, interactive: bool | None = None, visible: bool | Literal['hidden'] = True, elem_id: str | None = None, elem_classes: list[str] | str | None = None, render: bool = True, key: int | str | tuple[int | str, ...] | None = None, preserved_by_key: list[str] | str | None = \"value\", rtl: bool = False, buttons: list[Button] | None = None)`\nCreates a set of (string or numeric type) radio buttons of which only one can be selected..\n\n### `Image(value: str | PIL.Image.Image | np.ndarray | Callable | None = None, format: str = \"webp\", height: int | str | None = None, width: int | str | None = None, image_mode: Literal['1', 'L', 'P', 'RGB', 'RGBA', 'CMYK', 'YCbCr', 'LAB', 'HSV', 'I', 'F'] | None = \"RGB\", sources: list[Literal['upload', 'webcam', 'clipboard']] | Literal['upload', 'webcam', 'clipboard'] | None = None, type: Literal['numpy', 'pil', 'filepath'] = \"numpy\", label: str | I18nData | None = None, every: Timer | float | None = None, inputs: Component | Sequence[Component] | set[Component] | None = None, show_label: bool | None = None, buttons: list[Literal['download', 'share', 'fullscreen'] | Button] | None = None, container: bool = True, scale: int | None = None, min_width: int = 160, interactive: bool | None = None, visible: bool | Literal['hidden'] = True, streaming: bool = False, elem_id: str | None = None, elem_classes: list[str] | str | None = None, render: bool = True, key: int | str | tuple[int | str, ...] | None = None, preserved_by_key: list[str] | str | None = \"value\", webcam_options: WebcamOptions | None = None, placeholder: str | None = None, watermark: WatermarkOptions | None = None)`\nCreates an image component that can be used to upload images (as an input) or display images (as an output)..\n\n### `Audio(value: str | Path | tuple[int, np.ndarray] | Callable | None = None, sources: list[Literal['upload', 'microphone']] | Literal['upload', 'microphone'] | None = None, type: Literal['numpy', 'filepath'] = \"numpy\", label: str | I18nData | None = None, every: Timer | float | None = None, inputs: Component | Sequence[Component] | set[Component] | None = None, show_label: bool | None = None, container: bool = True, scale: int | None = None, min_width: int = 160, interactive: bool | None = None, visible: bool | Literal['hidden'] = True, streaming: bool = False, elem_id: str | None = None, elem_classes: list[str] | str | None = None, render: bool = True, key: int | str | tuple[int | str, ...] | None = None, preserved_by_key: list[str] | str | None = \"value\", format: Literal['wav', 'mp3'] | None = None, autoplay: bool = False, editable: bool = True, buttons: list[Literal['download', 'share'] | Button] | None = None, waveform_options: WaveformOptions | dict | None = None, loop: bool = False, recording: bool = False, subtitles: str | Path | list[dict[str, Any]] | None = None, playback_position: float = 0)`\nCreates an audio component that can be used to upload/record audio (as an input) or display audio (as an output)..\n\n### `Video(value: str | Path | Callable | None = None, format: str | None = None, sources: list[Literal['upload', 'webcam']] | Literal['upload', 'webcam'] | None = None, height: int | str | None = None, width: int | str | None = None, label: str | I18nData | None = None, every: Timer | float | None = None, inputs: Component | Sequence[Component] | set[Component] | None = None, show_label: bool | None = None, container: bool = True, scale: int | None = None, min_width: int = 160, interactive: bool | None = None, visible: bool | Literal['hidden'] = True, elem_id: str | None = None, elem_classes: list[str] | str | None = None, render: bool = True, key: int | str | tuple[int | str, ...] | None = None, preserved_by_key: list[str] | str | None = \"value\", webcam_options: WebcamOptions | None = None, include_audio: bool | None = None, autoplay: bool = False, buttons: list[Literal['download', 'share'] | Button] | None = None, loop: bool = False, streaming: bool = False, watermark: WatermarkOptions | None = None, subtitles: str | Path | list[dict[str, Any]] | None = None, playback_position: float = 0)`\nCreates a video component that can be used to upload/record videos (as an input) or display videos (as an output).\n\n### `File(value: str | list[str] | Callable | None = None, file_count: Literal['single', 'multiple', 'directory'] = \"single\", file_types: list[str] | None = None, type: Literal['filepath', 'binary'] = \"filepath\", label: str | I18nData | None = None, every: Timer | float | None = None, inputs: Component | Sequence[Component] | set[Component] | None = None, show_label: bool | None = None, container: bool = True, scale: int | None = None, min_width: int = 160, height: int | str | float | None = None, interactive: bool | None = None, visible: bool | Literal['hidden'] = True, elem_id: str | None = None, elem_classes: list[str] | str | None = None, render: bool = True, key: int | str | tuple[int | str, ...] | None = None, preserved_by_key: list[str] | str | None = \"value\", allow_reordering: bool = False, buttons: list[Button] | None = None)`\nCreates a file component that allows uploading one or more generic files (when used as an input) or displaying generic files or URLs for download (as output).\n\n### `Chatbot(value: list[MessageDict | Message] | Callable | None = None, label: str | I18nData | None = None, every: Timer | float | None = None, inputs: Component | Sequence[Component] | set[Component] | None = None, show_label: bool | None = None, container: bool = True, scale: int | None = None, min_width: int = 160, visible: bool | Literal['hidden'] = True, elem_id: str | None = None, elem_classes: list[str] | str | None = None, autoscroll: bool = True, render: bool = True, key: int | str | tuple[int | str, ...] | None = None, preserved_by_key: list[str] | str | None = \"value\", height: int | str | None = 400, resizable: bool = False, max_height: int | str | None = None, min_height: int | str | None = None, editable: Literal['user', 'all'] | None = None, latex_delimiters: list[dict[str, str | bool]] | None = None, rtl: bool = False, buttons: list[Literal['share', 'copy', 'copy_all'] | Button] | None = None, watermark: str | None = None, avatar_images: tuple[str | Path | None, str | Path | None] | None = None, sanitize_html: bool = True, render_markdown: bool = True, feedback_options: list[str] | tuple[str, ...] | None = ('Like', 'Dislike'), feedback_value: Sequence[str | None] | None = None, line_breaks: bool = True, layout: Literal['panel', 'bubble'] | None = None, placeholder: str | None = None, examples: list[ExampleMessage] | None = None, allow_file_downloads: <class 'inspect._empty'> = True, group_consecutive_messages: bool = True, allow_tags: list[str] | bool = True, reasoning_tags: list[tuple[str, str]] | None = None, like_user_message: bool = False)`\nCreates a chatbot that displays user-submitted messages and responses.\n\n### `Button(value: str | I18nData | Callable = \"Run\", every: Timer | float | None = None, inputs: Component | Sequence[Component] | set[Component] | None = None, variant: Literal['primary', 'secondary', 'stop', 'huggingface'] = \"secondary\", size: Literal['sm', 'md', 'lg'] = \"lg\", icon: str | Path | None = None, link: str | None = None, link_target: Literal['_self', '_blank', '_parent', '_top'] = \"_self\", visible: bool | Literal['hidden'] = True, interactive: bool = True, elem_id: str | None = None, elem_classes: list[str] | str | None = None, render: bool = True, key: int | str | tuple[int | str, ...] | None = None, preserved_by_key: list[str] | str | None = \"value\", scale: int | None = None, min_width: int | None = None)`\nCreates a button that can be assigned arbitrary .click() events.\n\n### `Markdown(value: str | I18nData | Callable | None = None, label: str | I18nData | None = None, every: Timer | float | None = None, inputs: Component | Sequence[Component] | set[Component] | None = None, show_label: bool | None = None, rtl: bool = False, latex_delimiters: list[dict[str, str | bool]] | None = None, visible: bool | Literal['hidden'] = True, elem_id: str | None = None, elem_classes: list[str] | str | None = None, render: bool = True, key: int | str | tuple[int | str, ...] | None = None, preserved_by_key: list[str] | str | None = \"value\", sanitize_html: bool = True, line_breaks: bool = False, header_links: bool = False, height: int | str | None = None, max_height: int | str | None = None, min_height: int | str | None = None, buttons: list[Literal['copy']] | None = None, container: bool = False, padding: bool = False)`\nUsed to render arbitrary Markdown output.\n\n### `HTML(value: Any | Callable | None = None, label: str | I18nData | None = None, html_template: str = \"${value}\", css_template: str = \"\", js_on_load: str | None = \"element.addEventListener('click', function() { trigger('click') });\", apply_default_css: bool = True, every: Timer | float | None = None, inputs: Component | Sequence[Component] | set[Component] | None = None, show_label: bool = False, visible: bool | Literal['hidden'] = True, elem_id: str | None = None, elem_classes: list[str] | str | None = None, render: bool = True, key: int | str | tuple[int | str, ...] | None = None, preserved_by_key: list[str] | str | None = \"value\", min_height: int | None = None, max_height: int | None = None, container: bool = False, padding: bool = False, autoscroll: bool = False, buttons: list[Button] | None = None, props: Any)`\nCreates a component with arbitrary HTML.\n\n\n## Custom HTML Components\n\nIf a task requires significant customization of an existing component or a component that doesn't exist in Gradio, you can create one with `gr.HTML`. It supports `html_template` (with `${}` JS expressions and `{{}}` Handlebars syntax), `css_template` for scoped styles, and `js_on_load` for interactivity ‚Äî where `props.value` updates the component value and `trigger('event_name')` fires Gradio events. For reuse, subclass `gr.HTML` and define `api_info()` for API/MCP support. See the [full guide](https://www.gradio.app/guides/custom-HTML-components).\n\nHere's an example that shows how to create and use these kinds of components:\n\n```python\nimport gradio as gr\n\nclass StarRating(gr.HTML):\n    def __init__(self, label, value=0, **kwargs):\n        html_template = \"\"\"\n        <h2>${label} rating:</h2>\n        ${Array.from({length: 5}, (_, i) => `<img class='${i < value ? '' : 'faded'}' src='https://upload.wikimedia.org/wikipedia/commons/d/df/Award-star-gold-3d.svg'>`).join('')}\n        \"\"\"\n        css_template = \"\"\"\n            img { height: 50px; display: inline-block; cursor: pointer; }\n            .faded { filter: grayscale(100%); opacity: 0.3; }\n        \"\"\"\n        js_on_load = \"\"\"\n            const imgs = element.querySelectorAll('img');\n            imgs.forEach((img, index) => {\n                img.addEventListener('click', () => {\n                    props.value = index + 1;\n                });\n            });\n        \"\"\"\n        super().__init__(value=value, label=label, html_template=html_template, css_template=css_template, js_on_load=js_on_load, **kwargs)\n\n    def api_info(self):\n        return {\"type\": \"integer\", \"minimum\": 0, \"maximum\": 5}\n\n\nwith gr.Blocks() as demo:\n    gr.Markdown(\"# Restaurant Review\")\n    food_rating = StarRating(label=\"Food\", value=3)\n    service_rating = StarRating(label=\"Service\", value=3)\n    ambience_rating = StarRating(label=\"Ambience\", value=3)\n    average_btn = gr.Button(\"Calculate Average Rating\")\n    rating_output = StarRating(label=\"Average\", value=3)\n    def calculate_average(food, service, ambience):\n        return round((food + service + ambience) / 3)\n    average_btn.click(\n        fn=calculate_average,\n        inputs=[food_rating, service_rating, ambience_rating],\n        outputs=rating_output\n    )\n\ndemo.launch()\n```\n\n## Event Listeners\n\nAll event listeners share the same signature:\n\n```python\ncomponent.event_name(\n    fn: Callable | None | Literal[\"decorator\"] = \"decorator\",\n    inputs: Component | Sequence[Component] | set[Component] | None = None,\n    outputs: Component | Sequence[Component] | set[Component] | None = None,\n    api_name: str | None = None,\n    api_description: str | None | Literal[False] = None,\n    scroll_to_output: bool = False,\n    show_progress: Literal[\"full\", \"minimal\", \"hidden\"] = \"full\",\n    show_progress_on: Component | Sequence[Component] | None = None,\n    queue: bool = True,\n    batch: bool = False,\n    max_batch_size: int = 4,\n    preprocess: bool = True,\n    postprocess: bool = True,\n    cancels: dict[str, Any] | list[dict[str, Any]] | None = None,\n    trigger_mode: Literal[\"once\", \"multiple\", \"always_last\"] | None = None,\n    js: str | Literal[True] | None = None,\n    concurrency_limit: int | None | Literal[\"default\"] = \"default\",\n    concurrency_id: str | None = None,\n    api_visibility: Literal[\"public\", \"private\", \"undocumented\"] = \"public\",\n    time_limit: int | None = None,\n    stream_every: float = 0.5,\n    key: int | str | tuple[int | str, ...] | None = None,\n    validator: Callable | None = None,\n) -> Dependency\n```\n\nSupported events per component:\n\n- **AnnotatedImage**: select\n- **Audio**: stream, change, clear, play, pause, stop, pause, start_recording, pause_recording, stop_recording, upload, input\n- **BarPlot**: select, double_click\n- **BrowserState**: change\n- **Button**: click\n- **Chatbot**: change, select, like, retry, undo, example_select, option_select, clear, copy, edit\n- **Checkbox**: change, input, select\n- **CheckboxGroup**: change, input, select\n- **ClearButton**: click\n- **Code**: change, input, focus, blur\n- **ColorPicker**: change, input, submit, focus, blur\n- **Dataframe**: change, input, select, edit\n- **Dataset**: click, select\n- **DateTime**: change, submit\n- **DeepLinkButton**: click\n- **Dialogue**: change, input, submit\n- **DownloadButton**: click\n- **Dropdown**: change, input, select, focus, blur, key_up\n- **DuplicateButton**: click\n- **File**: change, select, clear, upload, delete, download\n- **FileExplorer**: change, input, select\n- **Gallery**: select, upload, change, delete, preview_close, preview_open\n- **HTML**: change, input, click, double_click, submit, stop, edit, clear, play, pause, end, start_recording, pause_recording, stop_recording, focus, blur, upload, release, select, stream, like, example_select, option_select, load, key_up, apply, delete, tick, undo, retry, expand, collapse, download, copy\n- **HighlightedText**: change, select\n- **Image**: clear, change, stream, select, upload, input\n- **ImageEditor**: clear, change, input, select, upload, apply\n- **ImageSlider**: clear, change, stream, select, upload, input\n- **JSON**: change\n- **Label**: change, select\n- **LinePlot**: select, double_click\n- **LoginButton**: click\n- **Markdown**: change, copy\n- **Model3D**: change, upload, edit, clear\n- **MultimodalTextbox**: change, input, select, submit, focus, blur, stop\n- **Navbar**: change\n- **Number**: change, input, submit, focus, blur\n- **ParamViewer**: change, upload\n- **Plot**: change\n- **Radio**: select, change, input\n- **ScatterPlot**: select, double_click\n- **SimpleImage**: clear, change, upload\n- **Slider**: change, input, release\n- **State**: change\n- **Textbox**: change, input, select, submit, focus, blur, stop, copy\n- **Timer**: tick\n- **UploadButton**: click, upload\n- **Video**: change, clear, start_recording, stop_recording, stop, play, pause, end, upload, input\n\n## Additional Reference\n\n- [End-to-End Examples](examples.md) ‚Äî complete working apps"
    },
    {
      "id": "huggingface-skills-hugging-face-cli",
      "name": "hugging-face-cli",
      "slug": "hugging-face-cli",
      "description": "Execute Hugging Face Hub operations using the `hf` CLI. Use when the user needs to download models/datasets/spaces, upload files to Hub repositories, create repos, manage local cache, or run compute jobs on HF infrastructure. Covers authentication, file transfers, repository creation, cache operations, and cloud compute.",
      "category": "ML & Data",
      "platform": "HuggingFace",
      "platformIcon": "ü§ó",
      "source": "huggingface/skills",
      "sourceUrl": "https://github.com/huggingface/skills/tree/main/skills/hugging-face-cli",
      "skillMdUrl": "https://raw.githubusercontent.com/huggingface/skills/main/skills/hugging-face-cli/SKILL.md",
      "body": "# Hugging Face CLI\n\nThe `hf` CLI provides direct terminal access to the Hugging Face Hub for downloading, uploading, and managing repositories, cache, and compute resources.\n\n## Quick Command Reference\n\n| Task | Command |\n|------|---------|\n| Login | `hf auth login` |\n| Download model | `hf download <repo_id>` |\n| Download to folder | `hf download <repo_id> --local-dir ./path` |\n| Upload folder | `hf upload <repo_id> . .` |\n| Create repo | `hf repo create <name>` |\n| Create tag | `hf repo tag create <repo_id> <tag>` |\n| Delete files | `hf repo-files delete <repo_id> <files>` |\n| List cache | `hf cache ls` |\n| Remove from cache | `hf cache rm <repo_or_revision>` |\n| List models | `hf models ls` |\n| Get model info | `hf models info <model_id>` |\n| List datasets | `hf datasets ls` |\n| Get dataset info | `hf datasets info <dataset_id>` |\n| List spaces | `hf spaces ls` |\n| Get space info | `hf spaces info <space_id>` |\n| List endpoints | `hf endpoints ls` |\n| Run GPU job | `hf jobs run --flavor a10g-small <image> <cmd>` |\n| Environment info | `hf env` |\n\n## Core Commands\n\n### Authentication\n```bash\nhf auth login                    # Interactive login\nhf auth login --token $HF_TOKEN  # Non-interactive\nhf auth whoami                   # Check current user\nhf auth list                     # List stored tokens\nhf auth switch                   # Switch between tokens\nhf auth logout                   # Log out\n```\n\n### Download\n```bash\nhf download <repo_id>                              # Full repo to cache\nhf download <repo_id> file.safetensors             # Specific file\nhf download <repo_id> --local-dir ./models         # To local directory\nhf download <repo_id> --include \"*.safetensors\"    # Filter by pattern\nhf download <repo_id> --repo-type dataset          # Dataset\nhf download <repo_id> --revision v1.0              # Specific version\n```\n\n### Upload\n```bash\nhf upload <repo_id> . .                            # Current dir to root\nhf upload <repo_id> ./models /weights              # Folder to path\nhf upload <repo_id> model.safetensors              # Single file\nhf upload <repo_id> . . --repo-type dataset        # Dataset\nhf upload <repo_id> . . --create-pr                # Create PR\nhf upload <repo_id> . . --commit-message=\"msg\"     # Custom message\n```\n\n### Repository Management\n```bash\nhf repo create <name>                              # Create model repo\nhf repo create <name> --repo-type dataset          # Create dataset\nhf repo create <name> --private                    # Private repo\nhf repo create <name> --repo-type space --space_sdk gradio  # Gradio space\nhf repo delete <repo_id>                           # Delete repo\nhf repo move <from_id> <to_id>                     # Move repo to new namespace\nhf repo settings <repo_id> --private true          # Update repo settings\nhf repo list --repo-type model                     # List repos\nhf repo branch create <repo_id> release-v1         # Create branch\nhf repo branch delete <repo_id> release-v1         # Delete branch\nhf repo tag create <repo_id> v1.0                  # Create tag\nhf repo tag list <repo_id>                         # List tags\nhf repo tag delete <repo_id> v1.0                  # Delete tag\n```\n\n### Delete Files from Repo\n```bash\nhf repo-files delete <repo_id> folder/             # Delete folder\nhf repo-files delete <repo_id> \"*.txt\"             # Delete with pattern\n```\n\n### Cache Management\n```bash\nhf cache ls                      # List cached repos\nhf cache ls --revisions          # Include individual revisions\nhf cache rm model/gpt2           # Remove cached repo\nhf cache rm <revision_hash>      # Remove cached revision\nhf cache prune                   # Remove detached revisions\nhf cache verify gpt2             # Verify checksums from cache\n```\n\n### Browse Hub\n```bash\n# Models\nhf models ls                                        # List top trending models\nhf models ls --search \"MiniMax\" --author MiniMaxAI  # Search models\nhf models ls --filter \"text-generation\" --limit 20  # Filter by task\nhf models info MiniMaxAI/MiniMax-M2.1               # Get model info\n\n# Datasets\nhf datasets ls                                      # List top trending datasets\nhf datasets ls --search \"finepdfs\" --sort downloads # Search datasets\nhf datasets info HuggingFaceFW/finepdfs             # Get dataset info\n\n# Spaces\nhf spaces ls                                        # List top trending spaces\nhf spaces ls --filter \"3d\" --limit 10               # Filter by 3D modeling spaces\nhf spaces info enzostvs/deepsite                    # Get space info\n```\n\n### Jobs (Cloud Compute)\n```bash\nhf jobs run python:3.12 python script.py           # Run on CPU\nhf jobs run --flavor a10g-small <image> <cmd>      # Run on GPU\nhf jobs run --secrets HF_TOKEN <image> <cmd>       # With HF token\nhf jobs ps                                         # List jobs\nhf jobs logs <job_id>                              # View logs\nhf jobs cancel <job_id>                            # Cancel job\n```\n\n### Inference Endpoints\n```bash\nhf endpoints ls                                     # List endpoints\nhf endpoints deploy my-endpoint \\\n  --repo openai/gpt-oss-120b \\\n  --framework vllm \\\n  --accelerator gpu \\\n  --instance-size x4 \\\n  --instance-type nvidia-a10g \\\n  --region us-east-1 \\\n  --vendor aws\nhf endpoints describe my-endpoint                   # Show endpoint details\nhf endpoints pause my-endpoint                      # Pause endpoint\nhf endpoints resume my-endpoint                     # Resume endpoint\nhf endpoints scale-to-zero my-endpoint              # Scale to zero\nhf endpoints delete my-endpoint --yes               # Delete endpoint\n```\n**GPU Flavors:** `cpu-basic`, `cpu-upgrade`, `cpu-xl`, `t4-small`, `t4-medium`, `l4x1`, `l4x4`, `l40sx1`, `l40sx4`, `l40sx8`, `a10g-small`, `a10g-large`, `a10g-largex2`, `a10g-largex4`, `a100-large`, `h100`, `h100x8`\n\n## Common Patterns\n\n### Download and Use Model Locally\n```bash\n# Download to local directory for deployment\nhf download meta-llama/Llama-3.2-1B-Instruct --local-dir ./model\n\n# Or use cache and get path\nMODEL_PATH=$(hf download meta-llama/Llama-3.2-1B-Instruct --quiet)\n```\n\n### Publish Model/Dataset\n```bash\nhf repo create my-username/my-model --private\nhf upload my-username/my-model ./output . --commit-message=\"Initial release\"\nhf repo tag create my-username/my-model v1.0\n```\n\n### Sync Space with Local\n```bash\nhf upload my-username/my-space . . --repo-type space \\\n  --exclude=\"logs/*\" --delete=\"*\" --commit-message=\"Sync\"\n```\n\n### Check Cache Usage\n```bash\nhf cache ls                      # See all cached repos and sizes\nhf cache rm model/gpt2           # Remove a repo from cache\n```\n\n## Key Options\n\n- `--repo-type`: `model` (default), `dataset`, `space`\n- `--revision`: Branch, tag, or commit hash\n- `--token`: Override authentication\n- `--quiet`: Output only essential info (paths/URLs)\n\n## References\n\n- **Complete command reference**: See [references/commands.md](references/commands.md)\n- **Workflow examples**: See [references/examples.md](references/examples.md)"
    },
    {
      "id": "huggingface-skills-hugging-face-datasets",
      "name": "hugging-face-datasets",
      "slug": "hugging-face-datasets",
      "description": "Create and manage datasets on Hugging Face Hub. Supports initializing repos, defining configs/system prompts, streaming row updates, and SQL-based dataset querying/transformation. Designed to work alongside HF MCP server for comprehensive dataset workflows.",
      "category": "Git & Workflow",
      "platform": "HuggingFace",
      "platformIcon": "ü§ó",
      "source": "huggingface/skills",
      "sourceUrl": "https://github.com/huggingface/skills/tree/main/skills/hugging-face-datasets",
      "skillMdUrl": "https://raw.githubusercontent.com/huggingface/skills/main/skills/hugging-face-datasets/SKILL.md",
      "body": "# Overview\nThis skill provides tools to manage datasets on the Hugging Face Hub with a focus on creation, configuration, content management, and SQL-based data manipulation. It is designed to complement the existing Hugging Face MCP server by providing dataset editing and querying capabilities.\n\n## Integration with HF MCP Server\n- **Use HF MCP Server for**: Dataset discovery, search, and metadata retrieval\n- **Use This Skill for**: Dataset creation, content editing, SQL queries, data transformation, and structured data formatting\n\n# Version\n2.1.0\n\n# Dependencies\n# This skill uses PEP 723 scripts with inline dependency management\n# Scripts auto-install requirements when run with: uv run scripts/script_name.py\n\n- uv (Python package manager)\n- Getting Started: See \"Usage Instructions\" below for PEP 723 usage\n\n# Core Capabilities\n\n## 1. Dataset Lifecycle Management\n- **Initialize**: Create new dataset repositories with proper structure\n- **Configure**: Store detailed configuration including system prompts and metadata\n- **Stream Updates**: Add rows efficiently without downloading entire datasets\n\n## 2. SQL-Based Dataset Querying (NEW)\nQuery any Hugging Face dataset using DuckDB SQL via `scripts/sql_manager.py`:\n- **Direct Queries**: Run SQL on datasets using the `hf://` protocol\n- **Schema Discovery**: Describe dataset structure and column types\n- **Data Sampling**: Get random samples for exploration\n- **Aggregations**: Count, histogram, unique values analysis\n- **Transformations**: Filter, join, reshape data with SQL\n- **Export & Push**: Save results locally or push to new Hub repos\n\n## 3. Multi-Format Dataset Support\nSupports diverse dataset types through template system:\n- **Chat/Conversational**: Chat templating, multi-turn dialogues, tool usage examples\n- **Text Classification**: Sentiment analysis, intent detection, topic classification\n- **Question-Answering**: Reading comprehension, factual QA, knowledge bases\n- **Text Completion**: Language modeling, code completion, creative writing\n- **Tabular Data**: Structured data for regression/classification tasks\n- **Custom Formats**: Flexible schema definition for specialized needs\n\n## 4. Quality Assurance Features\n- **JSON Validation**: Ensures data integrity during uploads\n- **Batch Processing**: Efficient handling of large datasets\n- **Error Recovery**: Graceful handling of upload failures and conflicts\n\n# Usage Instructions\n\nThe skill includes two Python scripts that use PEP 723 inline dependency management:\n\n> **All paths are relative to the directory containing this SKILL.md\nfile.**\n> Scripts are run with: `uv run scripts/script_name.py [arguments]`\n\n- `scripts/dataset_manager.py` - Dataset creation and management\n- `scripts/sql_manager.py` - SQL-based dataset querying and transformation\n\n### Prerequisites\n- `uv` package manager installed\n- `HF_TOKEN` environment variable must be set with a Write-access token\n\n---\n\n# SQL Dataset Querying (sql_manager.py)\n\nQuery, transform, and push Hugging Face datasets using DuckDB SQL. The `hf://` protocol provides direct access to any public dataset (or private with token).\n\n## Quick Start\n\n```bash\n# Query a dataset\nuv run scripts/sql_manager.py query \\\n  --dataset \"cais/mmlu\" \\\n  --sql \"SELECT * FROM data WHERE subject='nutrition' LIMIT 10\"\n\n# Get dataset schema\nuv run scripts/sql_manager.py describe --dataset \"cais/mmlu\"\n\n# Sample random rows\nuv run scripts/sql_manager.py sample --dataset \"cais/mmlu\" --n 5\n\n# Count rows with filter\nuv run scripts/sql_manager.py count --dataset \"cais/mmlu\" --where \"subject='nutrition'\"\n```\n\n## SQL Query Syntax\n\nUse `data` as the table name in your SQL - it gets replaced with the actual `hf://` path:\n\n```sql\n-- Basic select\nSELECT * FROM data LIMIT 10\n\n-- Filtering\nSELECT * FROM data WHERE subject='nutrition'\n\n-- Aggregations\nSELECT subject, COUNT(*) as cnt FROM data GROUP BY subject ORDER BY cnt DESC\n\n-- Column selection and transformation\nSELECT question, choices[answer] AS correct_answer FROM data\n\n-- Regex matching\nSELECT * FROM data WHERE regexp_matches(question, 'nutrition|diet')\n\n-- String functions\nSELECT regexp_replace(question, '\\n', '') AS cleaned FROM data\n```\n\n## Common Operations\n\n### 1. Explore Dataset Structure\n```bash\n# Get schema\nuv run scripts/sql_manager.py describe --dataset \"cais/mmlu\"\n\n# Get unique values in column\nuv run scripts/sql_manager.py unique --dataset \"cais/mmlu\" --column \"subject\"\n\n# Get value distribution\nuv run scripts/sql_manager.py histogram --dataset \"cais/mmlu\" --column \"subject\" --bins 20\n```\n\n### 2. Filter and Transform\n```bash\n# Complex filtering with SQL\nuv run scripts/sql_manager.py query \\\n  --dataset \"cais/mmlu\" \\\n  --sql \"SELECT subject, COUNT(*) as cnt FROM data GROUP BY subject HAVING cnt > 100\"\n\n# Using transform command\nuv run scripts/sql_manager.py transform \\\n  --dataset \"cais/mmlu\" \\\n  --select \"subject, COUNT(*) as cnt\" \\\n  --group-by \"subject\" \\\n  --order-by \"cnt DESC\" \\\n  --limit 10\n```\n\n### 3. Create Subsets and Push to Hub\n```bash\n# Query and push to new dataset\nuv run scripts/sql_manager.py query \\\n  --dataset \"cais/mmlu\" \\\n  --sql \"SELECT * FROM data WHERE subject='nutrition'\" \\\n  --push-to \"username/mmlu-nutrition-subset\" \\\n  --private\n\n# Transform and push\nuv run scripts/sql_manager.py transform \\\n  --dataset \"ibm/duorc\" \\\n  --config \"ParaphraseRC\" \\\n  --select \"question, answers\" \\\n  --where \"LENGTH(question) > 50\" \\\n  --push-to \"username/duorc-long-questions\"\n```\n\n### 4. Export to Local Files\n```bash\n# Export to Parquet\nuv run scripts/sql_manager.py export \\\n  --dataset \"cais/mmlu\" \\\n  --sql \"SELECT * FROM data WHERE subject='nutrition'\" \\\n  --output \"nutrition.parquet\" \\\n  --format parquet\n\n# Export to JSONL\nuv run scripts/sql_manager.py export \\\n  --dataset \"cais/mmlu\" \\\n  --sql \"SELECT * FROM data LIMIT 100\" \\\n  --output \"sample.jsonl\" \\\n  --format jsonl\n```\n\n### 5. Working with Dataset Configs/Splits\n```bash\n# Specify config (subset)\nuv run scripts/sql_manager.py query \\\n  --dataset \"ibm/duorc\" \\\n  --config \"ParaphraseRC\" \\\n  --sql \"SELECT * FROM data LIMIT 5\"\n\n# Specify split\nuv run scripts/sql_manager.py query \\\n  --dataset \"cais/mmlu\" \\\n  --split \"test\" \\\n  --sql \"SELECT COUNT(*) FROM data\"\n\n# Query all splits\nuv run scripts/sql_manager.py query \\\n  --dataset \"cais/mmlu\" \\\n  --split \"*\" \\\n  --sql \"SELECT * FROM data LIMIT 10\"\n```\n\n### 6. Raw SQL with Full Paths\nFor complex queries or joining datasets:\n```bash\nuv run scripts/sql_manager.py raw --sql \"\n  SELECT a.*, b.* \n  FROM 'hf://datasets/dataset1@~parquet/default/train/*.parquet' a\n  JOIN 'hf://datasets/dataset2@~parquet/default/train/*.parquet' b\n  ON a.id = b.id\n  LIMIT 100\n\"\n```\n\n## Python API Usage\n\n```python\nfrom sql_manager import HFDatasetSQL\n\nsql = HFDatasetSQL()\n\n# Query\nresults = sql.query(\"cais/mmlu\", \"SELECT * FROM data WHERE subject='nutrition' LIMIT 10\")\n\n# Get schema\nschema = sql.describe(\"cais/mmlu\")\n\n# Sample\nsamples = sql.sample(\"cais/mmlu\", n=5, seed=42)\n\n# Count\ncount = sql.count(\"cais/mmlu\", where=\"subject='nutrition'\")\n\n# Histogram\ndist = sql.histogram(\"cais/mmlu\", \"subject\")\n\n# Filter and transform\nresults = sql.filter_and_transform(\n    \"cais/mmlu\",\n    select=\"subject, COUNT(*) as cnt\",\n    group_by=\"subject\",\n    order_by=\"cnt DESC\",\n    limit=10\n)\n\n# Push to Hub\nurl = sql.push_to_hub(\n    \"cais/mmlu\",\n    \"username/nutrition-subset\",\n    sql=\"SELECT * FROM data WHERE subject='nutrition'\",\n    private=True\n)\n\n# Export locally\nsql.export_to_parquet(\"cais/mmlu\", \"output.parquet\", sql=\"SELECT * FROM data LIMIT 100\")\n\nsql.close()\n```\n\n## HF Path Format\n\nDuckDB uses the `hf://` protocol to access datasets:\n```\nhf://datasets/{dataset_id}@{revision}/{config}/{split}/*.parquet\n```\n\nExamples:\n- `hf://datasets/cais/mmlu@~parquet/default/train/*.parquet`\n- `hf://datasets/ibm/duorc@~parquet/ParaphraseRC/test/*.parquet`\n\nThe `@~parquet` revision provides auto-converted Parquet files for any dataset format.\n\n## Useful DuckDB SQL Functions\n\n```sql\n-- String functions\nLENGTH(column)                    -- String length\nregexp_replace(col, '\\n', '')     -- Regex replace\nregexp_matches(col, 'pattern')    -- Regex match\nLOWER(col), UPPER(col)           -- Case conversion\n\n-- Array functions  \nchoices[0]                        -- Array indexing (0-based)\narray_length(choices)             -- Array length\nunnest(choices)                   -- Expand array to rows\n\n-- Aggregations\nCOUNT(*), SUM(col), AVG(col)\nGROUP BY col HAVING condition\n\n-- Sampling\nUSING SAMPLE 10                   -- Random sample\nUSING SAMPLE 10 (RESERVOIR, 42)   -- Reproducible sample\n\n-- Window functions\nROW_NUMBER() OVER (PARTITION BY col ORDER BY col2)\n```\n\n---\n\n# Dataset Creation (dataset_manager.py)\n\n### Recommended Workflow\n\n**1. Discovery (Use HF MCP Server):**\n```python\n# Use HF MCP tools to find existing datasets\nsearch_datasets(\"conversational AI training\")\nget_dataset_details(\"username/dataset-name\")\n```\n\n**2. Creation (Use This Skill):**\n```bash\n# Initialize new dataset\nuv run scripts/dataset_manager.py init --repo_id \"your-username/dataset-name\" [--private]\n\n# Configure with detailed system prompt\nuv run scripts/dataset_manager.py config --repo_id \"your-username/dataset-name\" --system_prompt \"$(cat system_prompt.txt)\"\n```\n\n**3. Content Management (Use This Skill):**\n```bash\n# Quick setup with any template\nuv run scripts/dataset_manager.py quick_setup \\\n  --repo_id \"your-username/dataset-name\" \\\n  --template classification\n\n# Add data with template validation\nuv run scripts/dataset_manager.py add_rows \\\n  --repo_id \"your-username/dataset-name\" \\\n  --template qa \\\n  --rows_json \"$(cat your_qa_data.json)\"\n```\n\n### Template-Based Data Structures\n\n**1. Chat Template (`--template chat`)**\n```json\n{\n  \"messages\": [\n    {\"role\": \"user\", \"content\": \"Natural user request\"},\n    {\"role\": \"assistant\", \"content\": \"Response with tool usage\"},\n    {\"role\": \"tool\", \"content\": \"Tool response\", \"tool_call_id\": \"call_123\"}\n  ],\n  \"scenario\": \"Description of use case\",\n  \"complexity\": \"simple|intermediate|advanced\"\n}\n```\n\n**2. Classification Template (`--template classification`)**\n```json\n{\n  \"text\": \"Input text to be classified\",\n  \"label\": \"classification_label\",\n  \"confidence\": 0.95,\n  \"metadata\": {\"domain\": \"technology\", \"language\": \"en\"}\n}\n```\n\n**3. QA Template (`--template qa`)**\n```json\n{\n  \"question\": \"What is the question being asked?\",\n  \"answer\": \"The complete answer\",\n  \"context\": \"Additional context if needed\",\n  \"answer_type\": \"factual|explanatory|opinion\",\n  \"difficulty\": \"easy|medium|hard\"\n}\n```\n\n**4. Completion Template (`--template completion`)**\n```json\n{\n  \"prompt\": \"The beginning text or context\",\n  \"completion\": \"The expected continuation\",\n  \"domain\": \"code|creative|technical|conversational\",\n  \"style\": \"description of writing style\"\n}\n```\n\n**5. Tabular Template (`--template tabular`)**\n```json\n{\n  \"columns\": [\n    {\"name\": \"feature1\", \"type\": \"numeric\", \"description\": \"First feature\"},\n    {\"name\": \"target\", \"type\": \"categorical\", \"description\": \"Target variable\"}\n  ],\n  \"data\": [\n    {\"feature1\": 123, \"target\": \"class_a\"},\n    {\"feature1\": 456, \"target\": \"class_b\"}\n  ]\n}\n```\n\n### Advanced System Prompt Template\n\nFor high-quality training data generation:\n```text\nYou are an AI assistant expert at using MCP tools effectively.\n\n## MCP SERVER DEFINITIONS\n[Define available servers and tools]\n\n## TRAINING EXAMPLE STRUCTURE\n[Specify exact JSON schema for chat templating]\n\n## QUALITY GUIDELINES\n[Detail requirements for realistic scenarios, progressive complexity, proper tool usage]\n\n## EXAMPLE CATEGORIES\n[List development workflows, debugging scenarios, data management tasks]\n```\n\n### Example Categories & Templates\n\nThe skill includes diverse training examples beyond just MCP usage:\n\n**Available Example Sets:**\n- `training_examples.json` - MCP tool usage examples (debugging, project setup, database analysis)\n- `diverse_training_examples.json` - Broader scenarios including:\n  - **Educational Chat** - Explaining programming concepts, tutorials\n  - **Git Workflows** - Feature branches, version control guidance\n  - **Code Analysis** - Performance optimization, architecture review\n  - **Content Generation** - Professional writing, creative brainstorming\n  - **Codebase Navigation** - Legacy code exploration, systematic analysis\n  - **Conversational Support** - Problem-solving, technical discussions\n\n**Using Different Example Sets:**\n```bash\n# Add MCP-focused examples\nuv run scripts/dataset_manager.py add_rows --repo_id \"your-username/dataset-name\" \\\n  --rows_json \"$(cat examples/training_examples.json)\"\n\n# Add diverse conversational examples\nuv run scripts/dataset_manager.py add_rows --repo_id \"your-username/dataset-name\" \\\n  --rows_json \"$(cat examples/diverse_training_examples.json)\"\n\n# Mix both for comprehensive training data\nuv run scripts/dataset_manager.py add_rows --repo_id \"your-username/dataset-name\" \\\n  --rows_json \"$(jq -s '.[0] + .[1]' examples/training_examples.json examples/diverse_training_examples.json)\"\n```\n\n### Commands Reference\n\n**List Available Templates:**\n```bash\nuv run scripts/dataset_manager.py list_templates\n```\n\n**Quick Setup (Recommended):**\n```bash\nuv run scripts/dataset_manager.py quick_setup --repo_id \"your-username/dataset-name\" --template classification\n```\n\n**Manual Setup:**\n```bash\n# Initialize repository\nuv run scripts/dataset_manager.py init --repo_id \"your-username/dataset-name\" [--private]\n\n# Configure with system prompt\nuv run scripts/dataset_manager.py config --repo_id \"your-username/dataset-name\" --system_prompt \"Your prompt here\"\n\n# Add data with validation\nuv run scripts/dataset_manager.py add_rows \\\n  --repo_id \"your-username/dataset-name\" \\\n  --template qa \\\n  --rows_json '[{\"question\": \"What is AI?\", \"answer\": \"Artificial Intelligence...\"}]'\n```\n\n**View Dataset Statistics:**\n```bash\nuv run scripts/dataset_manager.py stats --repo_id \"your-username/dataset-name\"\n```\n\n### Error Handling\n- **Repository exists**: Script will notify and continue with configuration\n- **Invalid JSON**: Clear error message with parsing details\n- **Network issues**: Automatic retry for transient failures\n- **Token permissions**: Validation before operations begin\n\n---\n\n# Combined Workflow Examples\n\n## Example 1: Create Training Subset from Existing Dataset\n```bash\n# 1. Explore the source dataset\nuv run scripts/sql_manager.py describe --dataset \"cais/mmlu\"\nuv run scripts/sql_manager.py histogram --dataset \"cais/mmlu\" --column \"subject\"\n\n# 2. Query and create subset\nuv run scripts/sql_manager.py query \\\n  --dataset \"cais/mmlu\" \\\n  --sql \"SELECT * FROM data WHERE subject IN ('nutrition', 'anatomy', 'clinical_knowledge')\" \\\n  --push-to \"username/mmlu-medical-subset\" \\\n  --private\n```\n\n## Example 2: Transform and Reshape Data\n```bash\n# Transform MMLU to QA format with correct answers extracted\nuv run scripts/sql_manager.py query \\\n  --dataset \"cais/mmlu\" \\\n  --sql \"SELECT question, choices[answer] as correct_answer, subject FROM data\" \\\n  --push-to \"username/mmlu-qa-format\"\n```\n\n## Example 3: Merge Multiple Dataset Splits\n```bash\n# Export multiple splits and combine\nuv run scripts/sql_manager.py export \\\n  --dataset \"cais/mmlu\" \\\n  --split \"*\" \\\n  --output \"mmlu_all.parquet\"\n```\n\n## Example 4: Quality Filtering\n```bash\n# Filter for high-quality examples\nuv run scripts/sql_manager.py query \\\n  --dataset \"squad\" \\\n  --sql \"SELECT * FROM data WHERE LENGTH(context) > 500 AND LENGTH(question) > 20\" \\\n  --push-to \"username/squad-filtered\"\n```\n\n## Example 5: Create Custom Training Dataset\n```bash\n# 1. Query source data\nuv run scripts/sql_manager.py export \\\n  --dataset \"cais/mmlu\" \\\n  --sql \"SELECT question, subject FROM data WHERE subject='nutrition'\" \\\n  --output \"nutrition_source.jsonl\" \\\n  --format jsonl\n\n# 2. Process with your pipeline (add answers, format, etc.)\n\n# 3. Push processed data\nuv run scripts/dataset_manager.py init --repo_id \"username/nutrition-training\"\nuv run scripts/dataset_manager.py add_rows \\\n  --repo_id \"username/nutrition-training\" \\\n  --template qa \\\n  --rows_json \"$(cat processed_data.json)\"\n```"
    },
    {
      "id": "huggingface-skills-hugging-face-evaluation",
      "name": "hugging-face-evaluation",
      "slug": "hugging-face-evaluation",
      "description": "Add and manage evaluation results in Hugging Face model cards. Supports extracting eval tables from README content, importing scores from Artificial Analysis API, and running custom model evaluations with vLLM/lighteval. Works with the model-index metadata format.",
      "category": "DevOps",
      "platform": "HuggingFace",
      "platformIcon": "ü§ó",
      "source": "huggingface/skills",
      "sourceUrl": "https://github.com/huggingface/skills/tree/main/skills/hugging-face-evaluation",
      "skillMdUrl": "https://raw.githubusercontent.com/huggingface/skills/main/skills/hugging-face-evaluation/SKILL.md",
      "body": "# Overview\nThis skill provides tools to add structured evaluation results to Hugging Face model cards. It supports multiple methods for adding evaluation data:\n- Extracting existing evaluation tables from README content\n- Importing benchmark scores from Artificial Analysis\n- Running custom model evaluations with vLLM or accelerate backends (lighteval/inspect-ai)\n\n## Integration with HF Ecosystem\n- **Model Cards**: Updates model-index metadata for leaderboard integration\n- **Artificial Analysis**: Direct API integration for benchmark imports\n- **Papers with Code**: Compatible with their model-index specification\n- **Jobs**: Run evaluations directly on Hugging Face Jobs with `uv` integration\n- **vLLM**: Efficient GPU inference for custom model evaluation\n- **lighteval**: HuggingFace's evaluation library with vLLM/accelerate backends\n- **inspect-ai**: UK AI Safety Institute's evaluation framework\n\n# Version\n1.3.0\n\n# Dependencies\n\n## Core Dependencies\n- huggingface_hub>=0.26.0\n- markdown-it-py>=3.0.0\n- python-dotenv>=1.2.1\n- pyyaml>=6.0.3\n- requests>=2.32.5\n- re (built-in)\n\n## Inference Provider Evaluation\n- inspect-ai>=0.3.0\n- inspect-evals\n- openai\n\n## vLLM Custom Model Evaluation (GPU required)\n- lighteval[accelerate,vllm]>=0.6.0\n- vllm>=0.4.0\n- torch>=2.0.0\n- transformers>=4.40.0\n- accelerate>=0.30.0\n\nNote: vLLM dependencies are installed automatically via PEP 723 script headers when using `uv run`.\n\n# IMPORTANT: Using This Skill\n\n## ‚ö†Ô∏è CRITICAL: Check for Existing PRs Before Creating New Ones\n\n**Before creating ANY pull request with `--create-pr`, you MUST check for existing open PRs:**\n\n```bash\nuv run scripts/evaluation_manager.py get-prs --repo-id \"username/model-name\"\n```\n\n**If open PRs exist:**\n1. **DO NOT create a new PR** - this creates duplicate work for maintainers\n2. **Warn the user** that open PRs already exist\n3. **Show the user** the existing PR URLs so they can review them\n4. Only proceed if the user explicitly confirms they want to create another PR\n\nThis prevents spamming model repositories with duplicate evaluation PRs.\n\n---\n\n> **All paths are relative to the directory containing this SKILL.md\nfile.**\n> Before running any script, first `cd` to that directory or use the full\npath.\n\n\n**Use `--help` for the latest workflow guidance.** Works with plain Python or `uv run`:\n```bash\nuv run scripts/evaluation_manager.py --help\nuv run scripts/evaluation_manager.py inspect-tables --help\nuv run scripts/evaluation_manager.py extract-readme --help\n```\nKey workflow (matches CLI help):\n\n1) `get-prs` ‚Üí check for existing open PRs first\n2) `inspect-tables` ‚Üí find table numbers/columns  \n3) `extract-readme --table N` ‚Üí prints YAML by default  \n4) add `--apply` (push) or `--create-pr` to write changes\n\n# Core Capabilities\n\n## 1. Inspect and Extract Evaluation Tables from README\n- **Inspect Tables**: Use `inspect-tables` to see all tables in a README with structure, columns, and sample rows\n- **Parse Markdown Tables**: Accurate parsing using markdown-it-py (ignores code blocks and examples)\n- **Table Selection**: Use `--table N` to extract from a specific table (required when multiple tables exist)\n- **Format Detection**: Recognize common formats (benchmarks as rows, columns, or comparison tables with multiple models)\n- **Column Matching**: Automatically identify model columns/rows; prefer `--model-column-index` (index from inspect output). Use `--model-name-override` only with exact column header text.\n- **YAML Generation**: Convert selected table to model-index YAML format\n- **Task Typing**: `--task-type` sets the `task.type` field in model-index output (e.g., `text-generation`, `summarization`)\n\n## 2. Import from Artificial Analysis\n- **API Integration**: Fetch benchmark scores directly from Artificial Analysis\n- **Automatic Formatting**: Convert API responses to model-index format\n- **Metadata Preservation**: Maintain source attribution and URLs\n- **PR Creation**: Automatically create pull requests with evaluation updates\n\n## 3. Model-Index Management\n- **YAML Generation**: Create properly formatted model-index entries\n- **Merge Support**: Add evaluations to existing model cards without overwriting\n- **Validation**: Ensure compliance with Papers with Code specification\n- **Batch Operations**: Process multiple models efficiently\n\n## 4. Run Evaluations on HF Jobs (Inference Providers)\n- **Inspect-AI Integration**: Run standard evaluations using the `inspect-ai` library\n- **UV Integration**: Seamlessly run Python scripts with ephemeral dependencies on HF infrastructure\n- **Zero-Config**: No Dockerfiles or Space management required\n- **Hardware Selection**: Configure CPU or GPU hardware for the evaluation job\n- **Secure Execution**: Handles API tokens safely via secrets passed through the CLI\n\n## 5. Run Custom Model Evaluations with vLLM (NEW)\n\n‚ö†Ô∏è **Important:** This approach is only possible on devices with `uv` installed and sufficient GPU memory.\n**Benefits:** No need to use `hf_jobs()` MCP tool, can run scripts directly in terminal\n**When to use:** User working in local device directly  when GPU is available\n\n### Before running the script\n\n- check the script path\n- check uv is installed\n- check gpu is available with `nvidia-smi`\n\n### Running the script\n\n```bash\nuv run scripts/train_sft_example.py\n```\n### Features\n\n- **vLLM Backend**: High-performance GPU inference (5-10x faster than standard HF methods)\n- **lighteval Framework**: HuggingFace's evaluation library with Open LLM Leaderboard tasks\n- **inspect-ai Framework**: UK AI Safety Institute's evaluation library\n- **Standalone or Jobs**: Run locally or submit to HF Jobs infrastructure\n\n# Usage Instructions\n\nThe skill includes Python scripts in `scripts/` to perform operations.\n\n### Prerequisites\n- Preferred: use `uv run` (PEP 723 header auto-installs deps)\n- Or install manually: `pip install huggingface-hub markdown-it-py python-dotenv pyyaml requests`\n- Set `HF_TOKEN` environment variable with Write-access token\n- For Artificial Analysis: Set `AA_API_KEY` environment variable\n- `.env` is loaded automatically if `python-dotenv` is installed\n\n### Method 1: Extract from README (CLI workflow)\n\nRecommended flow (matches `--help`):\n```bash\n# 1) Inspect tables to get table numbers and column hints\nuv run scripts/evaluation_manager.py inspect-tables --repo-id \"username/model\"\n\n# 2) Extract a specific table (prints YAML by default)\nuv run scripts/evaluation_manager.py extract-readme \\\n  --repo-id \"username/model\" \\\n  --table 1 \\\n  [--model-column-index <column index shown by inspect-tables>] \\\n  [--model-name-override \"<column header/model name>\"]  # use exact header text if you can't use the index\n\n# 3) Apply changes (push or PR)\nuv run scripts/evaluation_manager.py extract-readme \\\n  --repo-id \"username/model\" \\\n  --table 1 \\\n  --apply       # push directly\n# or\nuv run scripts/evaluation_manager.py extract-readme \\\n  --repo-id \"username/model\" \\\n  --table 1 \\\n  --create-pr   # open a PR\n```\n\nValidation checklist:\n- YAML is printed by default; compare against the README table before applying.\n- Prefer `--model-column-index`; if using `--model-name-override`, the column header text must be exact.\n- For transposed tables (models as rows), ensure only one row is extracted.\n\n### Method 2: Import from Artificial Analysis\n\nFetch benchmark scores from Artificial Analysis API and add them to a model card.\n\n**Basic Usage:**\n```bash\nAA_API_KEY=\"your-api-key\" uv run scripts/evaluation_manager.py import-aa \\\n  --creator-slug \"anthropic\" \\\n  --model-name \"claude-sonnet-4\" \\\n  --repo-id \"username/model-name\"\n```\n\n**With Environment File:**\n```bash\n# Create .env file\necho \"AA_API_KEY=your-api-key\" >> .env\necho \"HF_TOKEN=your-hf-token\" >> .env\n\n# Run import\nuv run scripts/evaluation_manager.py import-aa \\\n  --creator-slug \"anthropic\" \\\n  --model-name \"claude-sonnet-4\" \\\n  --repo-id \"username/model-name\"\n```\n\n**Create Pull Request:**\n```bash\nuv run scripts/evaluation_manager.py import-aa \\\n  --creator-slug \"anthropic\" \\\n  --model-name \"claude-sonnet-4\" \\\n  --repo-id \"username/model-name\" \\\n  --create-pr\n```\n\n### Method 3: Run Evaluation Job\n\nSubmit an evaluation job on Hugging Face infrastructure using the `hf jobs uv run` CLI.\n\n**Direct CLI Usage:**\n```bash\nHF_TOKEN=$HF_TOKEN \\\nhf jobs uv run hf-evaluation/scripts/inspect_eval_uv.py \\\n  --flavor cpu-basic \\\n  --secret HF_TOKEN=$HF_TOKEN \\\n  -- --model \"meta-llama/Llama-2-7b-hf\" \\\n     --task \"mmlu\"\n```\n\n**GPU Example (A10G):**\n```bash\nHF_TOKEN=$HF_TOKEN \\\nhf jobs uv run hf-evaluation/scripts/inspect_eval_uv.py \\\n  --flavor a10g-small \\\n  --secret HF_TOKEN=$HF_TOKEN \\\n  -- --model \"meta-llama/Llama-2-7b-hf\" \\\n     --task \"gsm8k\"\n```\n\n**Python Helper (optional):**\n```bash\nuv run scripts/run_eval_job.py \\\n  --model \"meta-llama/Llama-2-7b-hf\" \\\n  --task \"mmlu\" \\\n  --hardware \"t4-small\"\n```\n\n### Method 4: Run Custom Model Evaluation with vLLM\n\nEvaluate custom HuggingFace models directly on GPU using vLLM or accelerate backends. These scripts are **separate from inference provider scripts** and run models locally on the job's hardware.\n\n#### When to Use vLLM Evaluation (vs Inference Providers)\n\n| Feature | vLLM Scripts | Inference Provider Scripts |\n|---------|-------------|---------------------------|\n| Model access | Any HF model | Models with API endpoints |\n| Hardware | Your GPU (or HF Jobs GPU) | Provider's infrastructure |\n| Cost | HF Jobs compute cost | API usage fees |\n| Speed | vLLM optimized | Depends on provider |\n| Offline | Yes (after download) | No |\n\n#### Option A: lighteval with vLLM Backend\n\nlighteval is HuggingFace's evaluation library, supporting Open LLM Leaderboard tasks.\n\n**Standalone (local GPU):**\n```bash\n# Run MMLU 5-shot with vLLM\nuv run scripts/lighteval_vllm_uv.py \\\n  --model meta-llama/Llama-3.2-1B \\\n  --tasks \"leaderboard|mmlu|5\"\n\n# Run multiple tasks\nuv run scripts/lighteval_vllm_uv.py \\\n  --model meta-llama/Llama-3.2-1B \\\n  --tasks \"leaderboard|mmlu|5,leaderboard|gsm8k|5\"\n\n# Use accelerate backend instead of vLLM\nuv run scripts/lighteval_vllm_uv.py \\\n  --model meta-llama/Llama-3.2-1B \\\n  --tasks \"leaderboard|mmlu|5\" \\\n  --backend accelerate\n\n# Chat/instruction-tuned models\nuv run scripts/lighteval_vllm_uv.py \\\n  --model meta-llama/Llama-3.2-1B-Instruct \\\n  --tasks \"leaderboard|mmlu|5\" \\\n  --use-chat-template\n```\n\n**Via HF Jobs:**\n```bash\nhf jobs uv run scripts/lighteval_vllm_uv.py \\\n  --flavor a10g-small \\\n  --secrets HF_TOKEN=$HF_TOKEN \\\n  -- --model meta-llama/Llama-3.2-1B \\\n     --tasks \"leaderboard|mmlu|5\"\n```\n\n**lighteval Task Format:**\nTasks use the format `suite|task|num_fewshot`:\n- `leaderboard|mmlu|5` - MMLU with 5-shot\n- `leaderboard|gsm8k|5` - GSM8K with 5-shot\n- `lighteval|hellaswag|0` - HellaSwag zero-shot\n- `leaderboard|arc_challenge|25` - ARC-Challenge with 25-shot\n\n**Finding Available Tasks:**\nThe complete list of available lighteval tasks can be found at:\nhttps://github.com/huggingface/lighteval/blob/main/examples/tasks/all_tasks.txt\n\nThis file contains all supported tasks in the format `suite|task|num_fewshot|0` (the trailing `0` is a version flag and can be ignored). Common suites include:\n- `leaderboard` - Open LLM Leaderboard tasks (MMLU, GSM8K, ARC, HellaSwag, etc.)\n- `lighteval` - Additional lighteval tasks\n- `bigbench` - BigBench tasks\n- `original` - Original benchmark tasks\n\nTo use a task from the list, extract the `suite|task|num_fewshot` portion (without the trailing `0`) and pass it to the `--tasks` parameter. For example:\n- From file: `leaderboard|mmlu|0` ‚Üí Use: `leaderboard|mmlu|0` (or change to `5` for 5-shot)\n- From file: `bigbench|abstract_narrative_understanding|0` ‚Üí Use: `bigbench|abstract_narrative_understanding|0`\n- From file: `lighteval|wmt14:hi-en|0` ‚Üí Use: `lighteval|wmt14:hi-en|0`\n\nMultiple tasks can be specified as comma-separated values: `--tasks \"leaderboard|mmlu|5,leaderboard|gsm8k|5\"`\n\n#### Option B: inspect-ai with vLLM Backend\n\ninspect-ai is the UK AI Safety Institute's evaluation framework.\n\n**Standalone (local GPU):**\n```bash\n# Run MMLU with vLLM\nuv run scripts/inspect_vllm_uv.py \\\n  --model meta-llama/Llama-3.2-1B \\\n  --task mmlu\n\n# Use HuggingFace Transformers backend\nuv run scripts/inspect_vllm_uv.py \\\n  --model meta-llama/Llama-3.2-1B \\\n  --task mmlu \\\n  --backend hf\n\n# Multi-GPU with tensor parallelism\nuv run scripts/inspect_vllm_uv.py \\\n  --model meta-llama/Llama-3.2-70B \\\n  --task mmlu \\\n  --tensor-parallel-size 4\n```\n\n**Via HF Jobs:**\n```bash\nhf jobs uv run scripts/inspect_vllm_uv.py \\\n  --flavor a10g-small \\\n  --secrets HF_TOKEN=$HF_TOKEN \\\n  -- --model meta-llama/Llama-3.2-1B \\\n     --task mmlu\n```\n\n**Available inspect-ai Tasks:**\n- `mmlu` - Massive Multitask Language Understanding\n- `gsm8k` - Grade School Math\n- `hellaswag` - Common sense reasoning\n- `arc_challenge` - AI2 Reasoning Challenge\n- `truthfulqa` - TruthfulQA benchmark\n- `winogrande` - Winograd Schema Challenge\n- `humaneval` - Code generation\n\n#### Option C: Python Helper Script\n\nThe helper script auto-selects hardware and simplifies job submission:\n\n```bash\n# Auto-detect hardware based on model size\nuv run scripts/run_vllm_eval_job.py \\\n  --model meta-llama/Llama-3.2-1B \\\n  --task \"leaderboard|mmlu|5\" \\\n  --framework lighteval\n\n# Explicit hardware selection\nuv run scripts/run_vllm_eval_job.py \\\n  --model meta-llama/Llama-3.2-70B \\\n  --task mmlu \\\n  --framework inspect \\\n  --hardware a100-large \\\n  --tensor-parallel-size 4\n\n# Use HF Transformers backend\nuv run scripts/run_vllm_eval_job.py \\\n  --model microsoft/phi-2 \\\n  --task mmlu \\\n  --framework inspect \\\n  --backend hf\n```\n\n**Hardware Recommendations:**\n| Model Size | Recommended Hardware |\n|------------|---------------------|\n| < 3B params | `t4-small` |\n| 3B - 13B | `a10g-small` |\n| 13B - 34B | `a10g-large` |\n| 34B+ | `a100-large` |\n\n### Commands Reference\n\n**Top-level help and version:**\n```bash\nuv run scripts/evaluation_manager.py --help\nuv run scripts/evaluation_manager.py --version\n```\n\n**Inspect Tables (start here):**\n```bash\nuv run scripts/evaluation_manager.py inspect-tables --repo-id \"username/model-name\"\n```\n\n**Extract from README:**\n```bash\nuv run scripts/evaluation_manager.py extract-readme \\\n  --repo-id \"username/model-name\" \\\n  --table N \\\n  [--model-column-index N] \\\n  [--model-name-override \"Exact Column Header or Model Name\"] \\\n  [--task-type \"text-generation\"] \\\n  [--dataset-name \"Custom Benchmarks\"] \\\n  [--apply | --create-pr]\n```\n\n**Import from Artificial Analysis:**\n```bash\nAA_API_KEY=... uv run scripts/evaluation_manager.py import-aa \\\n  --creator-slug \"creator-name\" \\\n  --model-name \"model-slug\" \\\n  --repo-id \"username/model-name\" \\\n  [--create-pr]\n```\n\n**View / Validate:**\n```bash\nuv run scripts/evaluation_manager.py show --repo-id \"username/model-name\"\nuv run scripts/evaluation_manager.py validate --repo-id \"username/model-name\"\n```\n\n**Check Open PRs (ALWAYS run before --create-pr):**\n```bash\nuv run scripts/evaluation_manager.py get-prs --repo-id \"username/model-name\"\n```\nLists all open pull requests for the model repository. Shows PR number, title, author, date, and URL.\n\n**Run Evaluation Job (Inference Providers):**\n```bash\nhf jobs uv run scripts/inspect_eval_uv.py \\\n  --flavor \"cpu-basic|t4-small|...\" \\\n  --secret HF_TOKEN=$HF_TOKEN \\\n  -- --model \"model-id\" \\\n     --task \"task-name\"\n```\n\nor use the Python helper:\n\n```bash\nuv run scripts/run_eval_job.py \\\n  --model \"model-id\" \\\n  --task \"task-name\" \\\n  --hardware \"cpu-basic|t4-small|...\"\n```\n\n**Run vLLM Evaluation (Custom Models):**\n```bash\n# lighteval with vLLM\nhf jobs uv run scripts/lighteval_vllm_uv.py \\\n  --flavor \"a10g-small\" \\\n  --secrets HF_TOKEN=$HF_TOKEN \\\n  -- --model \"model-id\" \\\n     --tasks \"leaderboard|mmlu|5\"\n\n# inspect-ai with vLLM\nhf jobs uv run scripts/inspect_vllm_uv.py \\\n  --flavor \"a10g-small\" \\\n  --secrets HF_TOKEN=$HF_TOKEN \\\n  -- --model \"model-id\" \\\n     --task \"mmlu\"\n\n# Helper script (auto hardware selection)\nuv run scripts/run_vllm_eval_job.py \\\n  --model \"model-id\" \\\n  --task \"leaderboard|mmlu|5\" \\\n  --framework lighteval\n```\n\n### Model-Index Format\n\nThe generated model-index follows this structure:\n\n```yaml\nmodel-index:\n  - name: Model Name\n    results:\n      - task:\n          type: text-generation\n        dataset:\n          name: Benchmark Dataset\n          type: benchmark_type\n        metrics:\n          - name: MMLU\n            type: mmlu\n            value: 85.2\n          - name: HumanEval\n            type: humaneval\n            value: 72.5\n        source:\n          name: Source Name\n          url: https://source-url.com\n```\n\nWARNING: Do not use markdown formatting in the model name. Use the exact name from the table. Only use urls in the source.url field.\n\n### Error Handling\n- **Table Not Found**: Script will report if no evaluation tables are detected\n- **Invalid Format**: Clear error messages for malformed tables\n- **API Errors**: Retry logic for transient Artificial Analysis API failures\n- **Token Issues**: Validation before attempting updates\n- **Merge Conflicts**: Preserves existing model-index entries when adding new ones\n- **Space Creation**: Handles naming conflicts and hardware request failures gracefully\n\n### Best Practices\n\n1. **Check for existing PRs first**: Run `get-prs` before creating any new PR to avoid duplicates\n2. **Always start with `inspect-tables`**: See table structure and get the correct extraction command\n3. **Use `--help` for guidance**: Run `inspect-tables --help` to see the complete workflow\n4. **Preview first**: Default behavior prints YAML; review it before using `--apply` or `--create-pr`\n5. **Verify extracted values**: Compare YAML output against the README table manually\n6. **Use `--table N` for multi-table READMEs**: Required when multiple evaluation tables exist\n7. **Use `--model-name-override` for comparison tables**: Copy the exact column header from `inspect-tables` output\n8. **Create PRs for Others**: Use `--create-pr` when updating models you don't own\n9. **One model per repo**: Only add the main model's results to model-index\n10. **No markdown in YAML names**: The model name field in YAML should be plain text\n\n### Model Name Matching\n\nWhen extracting evaluation tables with multiple models (either as columns or rows), the script uses **exact normalized token matching**:\n\n- Removes markdown formatting (bold `**`, links `[]()`  )\n- Normalizes names (lowercase, replace `-` and `_` with spaces)\n- Compares token sets: `\"OLMo-3-32B\"` ‚Üí `{\"olmo\", \"3\", \"32b\"}` matches `\"**Olmo 3 32B**\"` or `\"[Olmo-3-32B](...)`\n- Only extracts if tokens match exactly (handles different word orders and separators)\n- Fails if no exact match found (rather than guessing from similar names)\n\n**For column-based tables** (benchmarks as rows, models as columns):\n- Finds the column header matching the model name\n- Extracts scores from that column only\n\n**For transposed tables** (models as rows, benchmarks as columns):\n- Finds the row in the first column matching the model name\n- Extracts all benchmark scores from that row only\n\nThis ensures only the correct model's scores are extracted, never unrelated models or training checkpoints. \n\n### Common Patterns\n\n**Update Your Own Model:**\n```bash\n# Extract from README and push directly\nuv run scripts/evaluation_manager.py extract-readme \\\n  --repo-id \"your-username/your-model\" \\\n  --task-type \"text-generation\"\n```\n\n**Update Someone Else's Model (Full Workflow):**\n```bash\n# Step 1: ALWAYS check for existing PRs first\nuv run scripts/evaluation_manager.py get-prs \\\n  --repo-id \"other-username/their-model\"\n\n# Step 2: If NO open PRs exist, proceed with creating one\nuv run scripts/evaluation_manager.py extract-readme \\\n  --repo-id \"other-username/their-model\" \\\n  --create-pr\n\n# If open PRs DO exist:\n# - Warn the user about existing PRs\n# - Show them the PR URLs\n# - Do NOT create a new PR unless user explicitly confirms\n```\n\n**Import Fresh Benchmarks:**\n```bash\n# Step 1: Check for existing PRs\nuv run scripts/evaluation_manager.py get-prs \\\n  --repo-id \"anthropic/claude-sonnet-4\"\n\n# Step 2: If no PRs, import from Artificial Analysis\nAA_API_KEY=... uv run scripts/evaluation_manager.py import-aa \\\n  --creator-slug \"anthropic\" \\\n  --model-name \"claude-sonnet-4\" \\\n  --repo-id \"anthropic/claude-sonnet-4\" \\\n  --create-pr\n```\n\n### Troubleshooting\n\n**Issue**: \"No evaluation tables found in README\"\n- **Solution**: Check if README contains markdown tables with numeric scores\n\n**Issue**: \"Could not find model 'X' in transposed table\"\n- **Solution**: The script will display available models. Use `--model-name-override` with the exact name from the list\n- **Example**: `--model-name-override \"**Olmo 3-32B**\"`\n\n**Issue**: \"AA_API_KEY not set\"\n- **Solution**: Set environment variable or add to .env file\n\n**Issue**: \"Token does not have write access\"\n- **Solution**: Ensure HF_TOKEN has write permissions for the repository\n\n**Issue**: \"Model not found in Artificial Analysis\"\n- **Solution**: Verify creator-slug and model-name match API values\n\n**Issue**: \"Payment required for hardware\"\n- **Solution**: Add a payment method to your Hugging Face account to use non-CPU hardware\n\n**Issue**: \"vLLM out of memory\" or CUDA OOM\n- **Solution**: Use a larger hardware flavor, reduce `--gpu-memory-utilization`, or use `--tensor-parallel-size` for multi-GPU\n\n**Issue**: \"Model architecture not supported by vLLM\"\n- **Solution**: Use `--backend hf` (inspect-ai) or `--backend accelerate` (lighteval) for HuggingFace Transformers\n\n**Issue**: \"Trust remote code required\"\n- **Solution**: Add `--trust-remote-code` flag for models with custom code (e.g., Phi-2, Qwen)\n\n**Issue**: \"Chat template not found\"\n- **Solution**: Only use `--use-chat-template` for instruction-tuned models that include a chat template\n\n### Integration Examples\n\n**Python Script Integration:**\n```python\nimport subprocess\nimport os\n\ndef update_model_evaluations(repo_id, readme_content):\n    \"\"\"Update model card with evaluations from README.\"\"\"\n    result = subprocess.run([\n        \"python\", \"scripts/evaluation_manager.py\",\n        \"extract-readme\",\n        \"--repo-id\", repo_id,\n        \"--create-pr\"\n    ], capture_output=True, text=True)\n\n    if result.returncode == 0:\n        print(f\"Successfully updated {repo_id}\")\n    else:\n        print(f\"Error: {result.stderr}\")\n```"
    },
    {
      "id": "huggingface-skills-hugging-face-jobs",
      "name": "hugging-face-jobs",
      "slug": "hugging-face-jobs",
      "description": "This skill should be used when users want to run any workload on Hugging Face Jobs infrastructure. Covers UV scripts, Docker-based jobs, hardware selection, cost estimation, authentication with tokens, secrets management, timeout configuration, and result persistence. Designed for general-purpose compute workloads including data processing, inference, experiments, batch jobs, and any Python-based tasks. Should be invoked for tasks involving cloud compute, GPU workloads, or when users mention running jobs on Hugging Face infrastructure without local setup.",
      "category": "Git & Workflow",
      "platform": "HuggingFace",
      "platformIcon": "ü§ó",
      "source": "huggingface/skills",
      "sourceUrl": "https://github.com/huggingface/skills/tree/main/skills/hugging-face-jobs",
      "skillMdUrl": "https://raw.githubusercontent.com/huggingface/skills/main/skills/hugging-face-jobs/SKILL.md",
      "body": "# Running Workloads on Hugging Face Jobs\n\n## Overview\n\nRun any workload on fully managed Hugging Face infrastructure. No local setup required‚Äîjobs run on cloud CPUs, GPUs, or TPUs and can persist results to the Hugging Face Hub.\n\n**Common use cases:**\n- **Data Processing** - Transform, filter, or analyze large datasets\n- **Batch Inference** - Run inference on thousands of samples\n- **Experiments & Benchmarks** - Reproducible ML experiments\n- **Model Training** - Fine-tune models (see `model-trainer` skill for TRL-specific training)\n- **Synthetic Data Generation** - Generate datasets using LLMs\n- **Development & Testing** - Test code without local GPU setup\n- **Scheduled Jobs** - Automate recurring tasks\n\n**For model training specifically:** See the `model-trainer` skill for TRL-based training workflows.\n\n## When to Use This Skill\n\nUse this skill when users want to:\n- Run Python workloads on cloud infrastructure\n- Execute jobs without local GPU/TPU setup\n- Process data at scale\n- Run batch inference or experiments\n- Schedule recurring tasks\n- Use GPUs/TPUs for any workload\n- Persist results to the Hugging Face Hub\n\n## Key Directives\n\nWhen assisting with jobs:\n\n1. **ALWAYS use `hf_jobs()` MCP tool** - Submit jobs using `hf_jobs(\"uv\", {...})` or `hf_jobs(\"run\", {...})`. The `script` parameter accepts Python code directly. Do NOT save to local files unless the user explicitly requests it. Pass the script content as a string to `hf_jobs()`.\n\n2. **Always handle authentication** - Jobs that interact with the Hub require `HF_TOKEN` via secrets. See Token Usage section below.\n\n3. **Provide job details after submission** - After submitting, provide job ID, monitoring URL, estimated time, and note that the user can request status checks later.\n\n4. **Set appropriate timeouts** - Default 30min may be insufficient for long-running tasks.\n\n## Prerequisites Checklist\n\nBefore starting any job, verify:\n\n### ‚úÖ **Account & Authentication**\n- Hugging Face Account with [Pro](https://hf.co/pro), [Team](https://hf.co/enterprise), or [Enterprise](https://hf.co/enterprise) plan (Jobs require paid plan)\n- Authenticated login: Check with `hf_whoami()`\n- **HF_TOKEN for Hub Access** ‚ö†Ô∏è CRITICAL - Required for any Hub operations (push models/datasets, download private repos, etc.)\n- Token must have appropriate permissions (read for downloads, write for uploads)\n\n### ‚úÖ **Token Usage** (See Token Usage section for details)\n\n**When tokens are required:**\n- Pushing models/datasets to Hub\n- Accessing private repositories\n- Using Hub APIs in scripts\n- Any authenticated Hub operations\n\n**How to provide tokens:**\n```python\n{\n    \"secrets\": {\"HF_TOKEN\": \"$HF_TOKEN\"}  # Recommended: automatic token\n}\n```\n\n**‚ö†Ô∏è CRITICAL:** The `$HF_TOKEN` placeholder is automatically replaced with your logged-in token. Never hardcode tokens in scripts.\n\n## Token Usage Guide\n\n### Understanding Tokens\n\n**What are HF Tokens?**\n- Authentication credentials for Hugging Face Hub\n- Required for authenticated operations (push, private repos, API access)\n- Stored securely on your machine after `hf auth login`\n\n**Token Types:**\n- **Read Token** - Can download models/datasets, read private repos\n- **Write Token** - Can push models/datasets, create repos, modify content\n- **Organization Token** - Can act on behalf of an organization\n\n### When Tokens Are Required\n\n**Always Required:**\n- Pushing models/datasets to Hub\n- Accessing private repositories\n- Creating new repositories\n- Modifying existing repositories\n- Using Hub APIs programmatically\n\n**Not Required:**\n- Downloading public models/datasets\n- Running jobs that don't interact with Hub\n- Reading public repository information\n\n### How to Provide Tokens to Jobs\n\n#### Method 1: Automatic Token (Recommended)\n\n```python\nhf_jobs(\"uv\", {\n    \"script\": \"your_script.py\",\n    \"secrets\": {\"HF_TOKEN\": \"$HF_TOKEN\"}  # ‚úÖ Automatic replacement\n})\n```\n\n**How it works:**\n- `$HF_TOKEN` is a placeholder that gets replaced with your actual token\n- Uses the token from your logged-in session (`hf auth login`)\n- Most secure and convenient method\n- Token is encrypted server-side when passed as a secret\n\n**Benefits:**\n- No token exposure in code\n- Uses your current login session\n- Automatically updated if you re-login\n- Works seamlessly with MCP tools\n\n#### Method 2: Explicit Token (Not Recommended)\n\n```python\nhf_jobs(\"uv\", {\n    \"script\": \"your_script.py\",\n    \"secrets\": {\"HF_TOKEN\": \"hf_abc123...\"}  # ‚ö†Ô∏è Hardcoded token\n})\n```\n\n**When to use:**\n- Only if automatic token doesn't work\n- Testing with a specific token\n- Organization tokens (use with caution)\n\n**Security concerns:**\n- Token visible in code/logs\n- Must manually update if token rotates\n- Risk of token exposure\n\n#### Method 3: Environment Variable (Less Secure)\n\n```python\nhf_jobs(\"uv\", {\n    \"script\": \"your_script.py\",\n    \"env\": {\"HF_TOKEN\": \"hf_abc123...\"}  # ‚ö†Ô∏è Less secure than secrets\n})\n```\n\n**Difference from secrets:**\n- `env` variables are visible in job logs\n- `secrets` are encrypted server-side\n- Always prefer `secrets` for tokens\n\n### Using Tokens in Scripts\n\n**In your Python script, tokens are available as environment variables:**\n\n```python\n# /// script\n# dependencies = [\"huggingface-hub\"]\n# ///\n\nimport os\nfrom huggingface_hub import HfApi\n\n# Token is automatically available if passed via secrets\ntoken = os.environ.get(\"HF_TOKEN\")\n\n# Use with Hub API\napi = HfApi(token=token)\n\n# Or let huggingface_hub auto-detect\napi = HfApi()  # Automatically uses HF_TOKEN env var\n```\n\n**Best practices:**\n- Don't hardcode tokens in scripts\n- Use `os.environ.get(\"HF_TOKEN\")` to access\n- Let `huggingface_hub` auto-detect when possible\n- Verify token exists before Hub operations\n\n### Token Verification\n\n**Check if you're logged in:**\n```python\nfrom huggingface_hub import whoami\nuser_info = whoami()  # Returns your username if authenticated\n```\n\n**Verify token in job:**\n```python\nimport os\nassert \"HF_TOKEN\" in os.environ, \"HF_TOKEN not found!\"\ntoken = os.environ[\"HF_TOKEN\"]\nprint(f\"Token starts with: {token[:7]}...\")  # Should start with \"hf_\"\n```\n\n### Common Token Issues\n\n**Error: 401 Unauthorized**\n- **Cause:** Token missing or invalid\n- **Fix:** Add `secrets={\"HF_TOKEN\": \"$HF_TOKEN\"}` to job config\n- **Verify:** Check `hf_whoami()` works locally\n\n**Error: 403 Forbidden**\n- **Cause:** Token lacks required permissions\n- **Fix:** Ensure token has write permissions for push operations\n- **Check:** Token type at https://huggingface.co/settings/tokens\n\n**Error: Token not found in environment**\n- **Cause:** `secrets` not passed or wrong key name\n- **Fix:** Use `secrets={\"HF_TOKEN\": \"$HF_TOKEN\"}` (not `env`)\n- **Verify:** Script checks `os.environ.get(\"HF_TOKEN\")`\n\n**Error: Repository access denied**\n- **Cause:** Token doesn't have access to private repo\n- **Fix:** Use token from account with access\n- **Check:** Verify repo visibility and your permissions\n\n### Token Security Best Practices\n\n1. **Never commit tokens** - Use `$HF_TOKEN` placeholder or environment variables\n2. **Use secrets, not env** - Secrets are encrypted server-side\n3. **Rotate tokens regularly** - Generate new tokens periodically\n4. **Use minimal permissions** - Create tokens with only needed permissions\n5. **Don't share tokens** - Each user should use their own token\n6. **Monitor token usage** - Check token activity in Hub settings\n\n### Complete Token Example\n\n```python\n# Example: Push results to Hub\nhf_jobs(\"uv\", {\n    \"script\": \"\"\"\n# /// script\n# dependencies = [\"huggingface-hub\", \"datasets\"]\n# ///\n\nimport os\nfrom huggingface_hub import HfApi\nfrom datasets import Dataset\n\n# Verify token is available\nassert \"HF_TOKEN\" in os.environ, \"HF_TOKEN required!\"\n\n# Use token for Hub operations\napi = HfApi(token=os.environ[\"HF_TOKEN\"])\n\n# Create and push dataset\ndata = {\"text\": [\"Hello\", \"World\"]}\ndataset = Dataset.from_dict(data)\ndataset.push_to_hub(\"username/my-dataset\", token=os.environ[\"HF_TOKEN\"])\n\nprint(\"‚úÖ Dataset pushed successfully!\")\n\"\"\",\n    \"flavor\": \"cpu-basic\",\n    \"timeout\": \"30m\",\n    \"secrets\": {\"HF_TOKEN\": \"$HF_TOKEN\"}  # ‚úÖ Token provided securely\n})\n```\n\n## Quick Start: Two Approaches\n\n### Approach 1: UV Scripts (Recommended)\n\nUV scripts use PEP 723 inline dependencies for clean, self-contained workloads.\n\n**MCP Tool:**\n```python\nhf_jobs(\"uv\", {\n    \"script\": \"\"\"\n# /// script\n# dependencies = [\"transformers\", \"torch\"]\n# ///\n\nfrom transformers import pipeline\nimport torch\n\n# Your workload here\nclassifier = pipeline(\"sentiment-analysis\")\nresult = classifier(\"I love Hugging Face!\")\nprint(result)\n\"\"\",\n    \"flavor\": \"cpu-basic\",\n    \"timeout\": \"30m\"\n})\n```\n\n**CLI Equivalent:**\n```bash\nhf jobs uv run my_script.py --flavor cpu-basic --timeout 30m\n```\n\n**Python API:**\n```python\nfrom huggingface_hub import run_uv_job\nrun_uv_job(\"my_script.py\", flavor=\"cpu-basic\", timeout=\"30m\")\n```\n\n**Benefits:** Direct MCP tool usage, clean code, dependencies declared inline, no file saving required\n\n**When to use:** Default choice for all workloads, custom logic, any scenario requiring `hf_jobs()`\n\n#### Custom Docker Images for UV Scripts\n\nBy default, UV scripts use `ghcr.io/astral-sh/uv:python3.12-bookworm-slim`. For ML workloads with complex dependencies, use pre-built images:\n\n```python\nhf_jobs(\"uv\", {\n    \"script\": \"inference.py\",\n    \"image\": \"vllm/vllm-openai:latest\",  # Pre-built image with vLLM\n    \"flavor\": \"a10g-large\"\n})\n```\n\n**CLI:**\n```bash\nhf jobs uv run --image vllm/vllm-openai:latest --flavor a10g-large inference.py\n```\n\n**Benefits:** Faster startup, pre-installed dependencies, optimized for specific frameworks\n\n#### Python Version\n\nBy default, UV scripts use Python 3.12. Specify a different version:\n\n```python\nhf_jobs(\"uv\", {\n    \"script\": \"my_script.py\",\n    \"python\": \"3.11\",  # Use Python 3.11\n    \"flavor\": \"cpu-basic\"\n})\n```\n\n**Python API:**\n```python\nfrom huggingface_hub import run_uv_job\nrun_uv_job(\"my_script.py\", python=\"3.11\")\n```\n\n#### Working with Scripts\n\n‚ö†Ô∏è **Important:** There are *two* \"script path\" stories depending on how you run Jobs:\n\n- **Using the `hf_jobs()` MCP tool (recommended in this repo)**: the `script` value must be **inline code** (a string) or a **URL**. A local filesystem path (like `\"./scripts/foo.py\"`) won't exist inside the remote container.\n- **Using the `hf jobs uv run` CLI**: local file paths **do work** (the CLI uploads your script).\n\n**Common mistake with `hf_jobs()` MCP tool:**\n\n```python\n# ‚ùå Will fail (remote container can't see your local path)\nhf_jobs(\"uv\", {\"script\": \"./scripts/foo.py\"})\n```\n\n**Correct patterns with `hf_jobs()` MCP tool:**\n\n```python\n# ‚úÖ Inline: read the local script file and pass its *contents*\nfrom pathlib import Path\nscript = Path(\"hf-jobs/scripts/foo.py\").read_text()\nhf_jobs(\"uv\", {\"script\": script})\n\n# ‚úÖ URL: host the script somewhere reachable\nhf_jobs(\"uv\", {\"script\": \"https://huggingface.co/datasets/uv-scripts/.../raw/main/foo.py\"})\n\n# ‚úÖ URL from GitHub\nhf_jobs(\"uv\", {\"script\": \"https://raw.githubusercontent.com/huggingface/trl/main/trl/scripts/sft.py\"})\n```\n\n**CLI equivalent (local paths supported):**\n\n```bash\nhf jobs uv run ./scripts/foo.py -- --your --args\n```\n\n#### Adding Dependencies at Runtime\n\nAdd extra dependencies beyond what's in the PEP 723 header:\n\n```python\nhf_jobs(\"uv\", {\n    \"script\": \"inference.py\",\n    \"dependencies\": [\"transformers\", \"torch>=2.0\"],  # Extra deps\n    \"flavor\": \"a10g-small\"\n})\n```\n\n**Python API:**\n```python\nfrom huggingface_hub import run_uv_job\nrun_uv_job(\"inference.py\", dependencies=[\"transformers\", \"torch>=2.0\"])\n```\n\n### Approach 2: Docker-Based Jobs\n\nRun jobs with custom Docker images and commands.\n\n**MCP Tool:**\n```python\nhf_jobs(\"run\", {\n    \"image\": \"python:3.12\",\n    \"command\": [\"python\", \"-c\", \"print('Hello from HF Jobs!')\"],\n    \"flavor\": \"cpu-basic\",\n    \"timeout\": \"30m\"\n})\n```\n\n**CLI Equivalent:**\n```bash\nhf jobs run python:3.12 python -c \"print('Hello from HF Jobs!')\"\n```\n\n**Python API:**\n```python\nfrom huggingface_hub import run_job\nrun_job(image=\"python:3.12\", command=[\"python\", \"-c\", \"print('Hello!')\"], flavor=\"cpu-basic\")\n```\n\n**Benefits:** Full Docker control, use pre-built images, run any command\n**When to use:** Need specific Docker images, non-Python workloads, complex environments\n\n**Example with GPU:**\n```python\nhf_jobs(\"run\", {\n    \"image\": \"pytorch/pytorch:2.6.0-cuda12.4-cudnn9-devel\",\n    \"command\": [\"python\", \"-c\", \"import torch; print(torch.cuda.get_device_name())\"],\n    \"flavor\": \"a10g-small\",\n    \"timeout\": \"1h\"\n})\n```\n\n**Using Hugging Face Spaces as Images:**\n\nYou can use Docker images from HF Spaces:\n```python\nhf_jobs(\"run\", {\n    \"image\": \"hf.co/spaces/lhoestq/duckdb\",  # Space as Docker image\n    \"command\": [\"duckdb\", \"-c\", \"SELECT 'Hello from DuckDB!'\"],\n    \"flavor\": \"cpu-basic\"\n})\n```\n\n**CLI:**\n```bash\nhf jobs run hf.co/spaces/lhoestq/duckdb duckdb -c \"SELECT 'Hello!'\"\n```\n\n### Finding More UV Scripts on Hub\n\nThe `uv-scripts` organization provides ready-to-use UV scripts stored as datasets on Hugging Face Hub:\n\n```python\n# Discover available UV script collections\ndataset_search({\"author\": \"uv-scripts\", \"sort\": \"downloads\", \"limit\": 20})\n\n# Explore a specific collection\nhub_repo_details([\"uv-scripts/classification\"], repo_type=\"dataset\", include_readme=True)\n```\n\n**Popular collections:** OCR, classification, synthetic-data, vLLM, dataset-creation\n\n## Hardware Selection\n\n> **Reference:** [HF Jobs Hardware Docs](https://huggingface.co/docs/hub/en/spaces-config-reference) (updated 07/2025)\n\n| Workload Type | Recommended Hardware | Use Case |\n|---------------|---------------------|----------|\n| Data processing, testing | `cpu-basic`, `cpu-upgrade` | Lightweight tasks |\n| Small models, demos | `t4-small` | <1B models, quick tests |\n| Medium models | `t4-medium`, `l4x1` | 1-7B models |\n| Large models, production | `a10g-small`, `a10g-large` | 7-13B models |\n| Very large models | `a100-large` | 13B+ models |\n| Batch inference | `a10g-large`, `a100-large` | High-throughput |\n| Multi-GPU workloads | `l4x4`, `a10g-largex2`, `a10g-largex4` | Parallel/large models |\n| TPU workloads | `v5e-1x1`, `v5e-2x2`, `v5e-2x4` | JAX/Flax, TPU-optimized |\n\n**All Available Flavors:**\n- **CPU:** `cpu-basic`, `cpu-upgrade`\n- **GPU:** `t4-small`, `t4-medium`, `l4x1`, `l4x4`, `a10g-small`, `a10g-large`, `a10g-largex2`, `a10g-largex4`, `a100-large`\n- **TPU:** `v5e-1x1`, `v5e-2x2`, `v5e-2x4`\n\n**Guidelines:**\n- Start with smaller hardware for testing\n- Scale up based on actual needs\n- Use multi-GPU for parallel workloads or large models\n- Use TPUs for JAX/Flax workloads\n- See `references/hardware_guide.md` for detailed specifications\n\n## Critical: Saving Results\n\n**‚ö†Ô∏è EPHEMERAL ENVIRONMENT‚ÄîMUST PERSIST RESULTS**\n\nThe Jobs environment is temporary. All files are deleted when the job ends. If results aren't persisted, **ALL WORK IS LOST**.\n\n### Persistence Options\n\n**1. Push to Hugging Face Hub (Recommended)**\n\n```python\n# Push models\nmodel.push_to_hub(\"username/model-name\", token=os.environ[\"HF_TOKEN\"])\n\n# Push datasets\ndataset.push_to_hub(\"username/dataset-name\", token=os.environ[\"HF_TOKEN\"])\n\n# Push artifacts\napi.upload_file(\n    path_or_fileobj=\"results.json\",\n    path_in_repo=\"results.json\",\n    repo_id=\"username/results\",\n    token=os.environ[\"HF_TOKEN\"]\n)\n```\n\n**2. Use External Storage**\n\n```python\n# Upload to S3, GCS, etc.\nimport boto3\ns3 = boto3.client('s3')\ns3.upload_file('results.json', 'my-bucket', 'results.json')\n```\n\n**3. Send Results via API**\n\n```python\n# POST results to your API\nimport requests\nrequests.post(\"https://your-api.com/results\", json=results)\n```\n\n### Required Configuration for Hub Push\n\n**In job submission:**\n```python\n{\n    \"secrets\": {\"HF_TOKEN\": \"$HF_TOKEN\"}  # Enables authentication\n}\n```\n\n**In script:**\n```python\nimport os\nfrom huggingface_hub import HfApi\n\n# Token automatically available from secrets\napi = HfApi(token=os.environ.get(\"HF_TOKEN\"))\n\n# Push your results\napi.upload_file(...)\n```\n\n### Verification Checklist\n\nBefore submitting:\n- [ ] Results persistence method chosen\n- [ ] `secrets={\"HF_TOKEN\": \"$HF_TOKEN\"}` if using Hub\n- [ ] Script handles missing token gracefully\n- [ ] Test persistence path works\n\n**See:** `references/hub_saving.md` for detailed Hub persistence guide\n\n## Timeout Management\n\n**‚ö†Ô∏è DEFAULT: 30 MINUTES**\n\nJobs automatically stop after the timeout. For long-running tasks like training, always set a custom timeout.\n\n### Setting Timeouts\n\n**MCP Tool:**\n```python\n{\n    \"timeout\": \"2h\"   # 2 hours\n}\n```\n\n**Supported formats:**\n- Integer/float: seconds (e.g., `300` = 5 minutes)\n- String with suffix: `\"5m\"` (minutes), `\"2h\"` (hours), `\"1d\"` (days)\n- Examples: `\"90m\"`, `\"2h\"`, `\"1.5h\"`, `300`, `\"1d\"`\n\n**Python API:**\n```python\nfrom huggingface_hub import run_job, run_uv_job\n\nrun_job(image=\"python:3.12\", command=[...], timeout=\"2h\")\nrun_uv_job(\"script.py\", timeout=7200)  # 2 hours in seconds\n```\n\n### Timeout Guidelines\n\n| Scenario | Recommended | Notes |\n|----------|-------------|-------|\n| Quick test | 10-30 min | Verify setup |\n| Data processing | 1-2 hours | Depends on data size |\n| Batch inference | 2-4 hours | Large batches |\n| Experiments | 4-8 hours | Multiple runs |\n| Long-running | 8-24 hours | Production workloads |\n\n**Always add 20-30% buffer** for setup, network delays, and cleanup.\n\n**On timeout:** Job killed immediately, all unsaved progress lost\n\n## Cost Estimation\n\n**General guidelines:**\n\n```\nTotal Cost = (Hours of runtime) √ó (Cost per hour)\n```\n\n**Example calculations:**\n\n**Quick test:**\n- Hardware: cpu-basic ($0.10/hour)\n- Time: 15 minutes (0.25 hours)\n- Cost: $0.03\n\n**Data processing:**\n- Hardware: l4x1 ($2.50/hour)\n- Time: 2 hours\n- Cost: $5.00\n\n**Batch inference:**\n- Hardware: a10g-large ($5/hour)\n- Time: 4 hours\n- Cost: $20.00\n\n**Cost optimization tips:**\n1. Start small - Test on cpu-basic or t4-small\n2. Monitor runtime - Set appropriate timeouts\n3. Use checkpoints - Resume if job fails\n4. Optimize code - Reduce unnecessary compute\n5. Choose right hardware - Don't over-provision\n\n## Monitoring and Tracking\n\n### Check Job Status\n\n**MCP Tool:**\n```python\n# List all jobs\nhf_jobs(\"ps\")\n\n# Inspect specific job\nhf_jobs(\"inspect\", {\"job_id\": \"your-job-id\"})\n\n# View logs\nhf_jobs(\"logs\", {\"job_id\": \"your-job-id\"})\n\n# Cancel a job\nhf_jobs(\"cancel\", {\"job_id\": \"your-job-id\"})\n```\n\n**Python API:**\n```python\nfrom huggingface_hub import list_jobs, inspect_job, fetch_job_logs, cancel_job\n\n# List your jobs\njobs = list_jobs()\n\n# List running jobs only\nrunning = [j for j in list_jobs() if j.status.stage == \"RUNNING\"]\n\n# Inspect specific job\njob_info = inspect_job(job_id=\"your-job-id\")\n\n# View logs\nfor log in fetch_job_logs(job_id=\"your-job-id\"):\n    print(log)\n\n# Cancel a job\ncancel_job(job_id=\"your-job-id\")\n```\n\n**CLI:**\n```bash\nhf jobs ps                    # List jobs\nhf jobs logs <job-id>         # View logs\nhf jobs cancel <job-id>       # Cancel job\n```\n\n**Remember:** Wait for user to request status checks. Avoid polling repeatedly.\n\n### Job URLs\n\nAfter submission, jobs have monitoring URLs:\n```\nhttps://huggingface.co/jobs/username/job-id\n```\n\nView logs, status, and details in the browser.\n\n### Wait for Multiple Jobs\n\n```python\nimport time\nfrom huggingface_hub import inspect_job, run_job\n\n# Run multiple jobs\njobs = [run_job(image=img, command=cmd) for img, cmd in workloads]\n\n# Wait for all to complete\nfor job in jobs:\n    while inspect_job(job_id=job.id).status.stage not in (\"COMPLETED\", \"ERROR\"):\n        time.sleep(10)\n```\n\n## Scheduled Jobs\n\nRun jobs on a schedule using CRON expressions or predefined schedules.\n\n**MCP Tool:**\n```python\n# Schedule a UV script that runs every hour\nhf_jobs(\"scheduled uv\", {\n    \"script\": \"your_script.py\",\n    \"schedule\": \"@hourly\",\n    \"flavor\": \"cpu-basic\"\n})\n\n# Schedule with CRON syntax\nhf_jobs(\"scheduled uv\", {\n    \"script\": \"your_script.py\",\n    \"schedule\": \"0 9 * * 1\",  # 9 AM every Monday\n    \"flavor\": \"cpu-basic\"\n})\n\n# Schedule a Docker-based job\nhf_jobs(\"scheduled run\", {\n    \"image\": \"python:3.12\",\n    \"command\": [\"python\", \"-c\", \"print('Scheduled!')\"],\n    \"schedule\": \"@daily\",\n    \"flavor\": \"cpu-basic\"\n})\n```\n\n**Python API:**\n```python\nfrom huggingface_hub import create_scheduled_job, create_scheduled_uv_job\n\n# Schedule a Docker job\ncreate_scheduled_job(\n    image=\"python:3.12\",\n    command=[\"python\", \"-c\", \"print('Running on schedule!')\"],\n    schedule=\"@hourly\"\n)\n\n# Schedule a UV script\ncreate_scheduled_uv_job(\"my_script.py\", schedule=\"@daily\", flavor=\"cpu-basic\")\n\n# Schedule with GPU\ncreate_scheduled_uv_job(\n    \"ml_inference.py\",\n    schedule=\"0 */6 * * *\",  # Every 6 hours\n    flavor=\"a10g-small\"\n)\n```\n\n**Available schedules:**\n- `@annually`, `@yearly` - Once per year\n- `@monthly` - Once per month\n- `@weekly` - Once per week\n- `@daily` - Once per day\n- `@hourly` - Once per hour\n- CRON expression - Custom schedule (e.g., `\"*/5 * * * *\"` for every 5 minutes)\n\n**Manage scheduled jobs:**\n```python\n# MCP Tool\nhf_jobs(\"scheduled ps\")                              # List scheduled jobs\nhf_jobs(\"scheduled inspect\", {\"job_id\": \"...\"})     # Inspect details\nhf_jobs(\"scheduled suspend\", {\"job_id\": \"...\"})     # Pause\nhf_jobs(\"scheduled resume\", {\"job_id\": \"...\"})      # Resume\nhf_jobs(\"scheduled delete\", {\"job_id\": \"...\"})      # Delete\n```\n\n**Python API for management:**\n```python\nfrom huggingface_hub import (\n    list_scheduled_jobs,\n    inspect_scheduled_job,\n    suspend_scheduled_job,\n    resume_scheduled_job,\n    delete_scheduled_job\n)\n\n# List all scheduled jobs\nscheduled = list_scheduled_jobs()\n\n# Inspect a scheduled job\ninfo = inspect_scheduled_job(scheduled_job_id)\n\n# Suspend (pause) a scheduled job\nsuspend_scheduled_job(scheduled_job_id)\n\n# Resume a scheduled job\nresume_scheduled_job(scheduled_job_id)\n\n# Delete a scheduled job\ndelete_scheduled_job(scheduled_job_id)\n```\n\n## Webhooks: Trigger Jobs on Events\n\nTrigger jobs automatically when changes happen in Hugging Face repositories.\n\n**Python API:**\n```python\nfrom huggingface_hub import create_webhook\n\n# Create webhook that triggers a job when a repo changes\nwebhook = create_webhook(\n    job_id=job.id,\n    watched=[\n        {\"type\": \"user\", \"name\": \"your-username\"},\n        {\"type\": \"org\", \"name\": \"your-org-name\"}\n    ],\n    domains=[\"repo\", \"discussion\"],\n    secret=\"your-secret\"\n)\n```\n\n**How it works:**\n1. Webhook listens for changes in watched repositories\n2. When triggered, the job runs with `WEBHOOK_PAYLOAD` environment variable\n3. Your script can parse the payload to understand what changed\n\n**Use cases:**\n- Auto-process new datasets when uploaded\n- Trigger inference when models are updated\n- Run tests when code changes\n- Generate reports on repository activity\n\n**Access webhook payload in script:**\n```python\nimport os\nimport json\n\npayload = json.loads(os.environ.get(\"WEBHOOK_PAYLOAD\", \"{}\"))\nprint(f\"Event type: {payload.get('event', {}).get('action')}\")\n```\n\nSee [Webhooks Documentation](https://huggingface.co/docs/huggingface_hub/guides/webhooks) for more details.\n\n## Common Workload Patterns\n\nThis repository ships ready-to-run UV scripts in `hf-jobs/scripts/`. Prefer using them instead of inventing new templates.\n\n### Pattern 1: Dataset ‚Üí Model Responses (vLLM) ‚Äî `scripts/generate-responses.py`\n\n**What it does:** loads a Hub dataset (chat `messages` or a `prompt` column), applies a model chat template, generates responses with vLLM, and **pushes** the output dataset + dataset card back to the Hub.\n\n**Requires:** GPU + **write** token (it pushes a dataset).\n\n```python\nfrom pathlib import Path\n\nscript = Path(\"hf-jobs/scripts/generate-responses.py\").read_text()\nhf_jobs(\"uv\", {\n    \"script\": script,\n    \"script_args\": [\n        \"username/input-dataset\",\n        \"username/output-dataset\",\n        \"--messages-column\", \"messages\",\n        \"--model-id\", \"Qwen/Qwen3-30B-A3B-Instruct-2507\",\n        \"--temperature\", \"0.7\",\n        \"--top-p\", \"0.8\",\n        \"--max-tokens\", \"2048\",\n    ],\n    \"flavor\": \"a10g-large\",\n    \"timeout\": \"4h\",\n    \"secrets\": {\"HF_TOKEN\": \"$HF_TOKEN\"},\n})\n```\n\n### Pattern 2: CoT Self-Instruct Synthetic Data ‚Äî `scripts/cot-self-instruct.py`\n\n**What it does:** generates synthetic prompts/answers via CoT Self-Instruct, optionally filters outputs (answer-consistency / RIP), then **pushes** the generated dataset + dataset card to the Hub.\n\n**Requires:** GPU + **write** token (it pushes a dataset).\n\n```python\nfrom pathlib import Path\n\nscript = Path(\"hf-jobs/scripts/cot-self-instruct.py\").read_text()\nhf_jobs(\"uv\", {\n    \"script\": script,\n    \"script_args\": [\n        \"--seed-dataset\", \"davanstrien/s1k-reasoning\",\n        \"--output-dataset\", \"username/synthetic-math\",\n        \"--task-type\", \"reasoning\",\n        \"--num-samples\", \"5000\",\n        \"--filter-method\", \"answer-consistency\",\n    ],\n    \"flavor\": \"l4x4\",\n    \"timeout\": \"8h\",\n    \"secrets\": {\"HF_TOKEN\": \"$HF_TOKEN\"},\n})\n```\n\n### Pattern 3: Streaming Dataset Stats (Polars + HF Hub) ‚Äî `scripts/finepdfs-stats.py`\n\n**What it does:** scans parquet directly from Hub (no 300GB download), computes temporal stats, and (optionally) uploads results to a Hub dataset repo.\n\n**Requires:** CPU is often enough; token needed **only** if you pass `--output-repo` (upload).\n\n```python\nfrom pathlib import Path\n\nscript = Path(\"hf-jobs/scripts/finepdfs-stats.py\").read_text()\nhf_jobs(\"uv\", {\n    \"script\": script,\n    \"script_args\": [\n        \"--limit\", \"10000\",\n        \"--show-plan\",\n        \"--output-repo\", \"username/finepdfs-temporal-stats\",\n    ],\n    \"flavor\": \"cpu-upgrade\",\n    \"timeout\": \"2h\",\n    \"env\": {\"HF_XET_HIGH_PERFORMANCE\": \"1\"},\n    \"secrets\": {\"HF_TOKEN\": \"$HF_TOKEN\"},\n})\n```\n\n## Common Failure Modes\n\n### Out of Memory (OOM)\n\n**Fix:**\n1. Reduce batch size or data chunk size\n2. Process data in smaller batches\n3. Upgrade hardware: cpu ‚Üí t4 ‚Üí a10g ‚Üí a100\n\n### Job Timeout\n\n**Fix:**\n1. Check logs for actual runtime\n2. Increase timeout with buffer: `\"timeout\": \"3h\"`\n3. Optimize code for faster execution\n4. Process data in chunks\n\n### Hub Push Failures\n\n**Fix:**\n1. Add to job: `secrets={\"HF_TOKEN\": \"$HF_TOKEN\"}`\n2. Verify token in script: `assert \"HF_TOKEN\" in os.environ`\n3. Check token permissions\n4. Verify repo exists or can be created\n\n### Missing Dependencies\n\n**Fix:**\nAdd to PEP 723 header:\n```python\n# /// script\n# dependencies = [\"package1\", \"package2>=1.0.0\"]\n# ///\n```\n\n### Authentication Errors\n\n**Fix:**\n1. Check `hf_whoami()` works locally\n2. Verify `secrets={\"HF_TOKEN\": \"$HF_TOKEN\"}` in job config\n3. Re-login: `hf auth login`\n4. Check token has required permissions\n\n## Troubleshooting\n\n**Common issues:**\n- Job times out ‚Üí Increase timeout, optimize code\n- Results not saved ‚Üí Check persistence method, verify HF_TOKEN\n- Out of Memory ‚Üí Reduce batch size, upgrade hardware\n- Import errors ‚Üí Add dependencies to PEP 723 header\n- Authentication errors ‚Üí Check token, verify secrets parameter\n\n**See:** `references/troubleshooting.md` for complete troubleshooting guide\n\n## Resources\n\n### References (In This Skill)\n- `references/token_usage.md` - Complete token usage guide\n- `references/hardware_guide.md` - Hardware specs and selection\n- `references/hub_saving.md` - Hub persistence guide\n- `references/troubleshooting.md` - Common issues and solutions\n\n### Scripts (In This Skill)\n- `scripts/generate-responses.py` - vLLM batch generation: dataset ‚Üí responses ‚Üí push to Hub\n- `scripts/cot-self-instruct.py` - CoT Self-Instruct synthetic data generation + filtering ‚Üí push to Hub\n- `scripts/finepdfs-stats.py` - Polars streaming stats over `finepdfs-edu` parquet on Hub (optional push)\n\n### External Links\n\n**Official Documentation:**\n- [HF Jobs Guide](https://huggingface.co/docs/huggingface_hub/guides/jobs) - Main documentation\n- [HF Jobs CLI Reference](https://huggingface.co/docs/huggingface_hub/guides/cli#hf-jobs) - Command line interface\n- [HF Jobs API Reference](https://huggingface.co/docs/huggingface_hub/package_reference/hf_api) - Python API details\n- [Hardware Flavors Reference](https://huggingface.co/docs/hub/en/spaces-config-reference) - Available hardware\n\n**Related Tools:**\n- [UV Scripts Guide](https://docs.astral.sh/uv/guides/scripts/) - PEP 723 inline dependencies\n- [UV Scripts Organization](https://huggingface.co/uv-scripts) - Community UV script collection\n- [HF Hub Authentication](https://huggingface.co/docs/huggingface_hub/quick-start#authentication) - Token setup\n- [Webhooks Documentation](https://huggingface.co/docs/huggingface_hub/guides/webhooks) - Event triggers\n\n## Key Takeaways\n\n1. **Submit scripts inline** - The `script` parameter accepts Python code directly; no file saving required unless user requests\n2. **Jobs are asynchronous** - Don't wait/poll; let user check when ready\n3. **Always set timeout** - Default 30 min may be insufficient; set appropriate timeout\n4. **Always persist results** - Environment is ephemeral; without persistence, all work is lost\n5. **Use tokens securely** - Always use `secrets={\"HF_TOKEN\": \"$HF_TOKEN\"}` for Hub operations\n6. **Choose appropriate hardware** - Start small, scale up based on needs (see hardware guide)\n7. **Use UV scripts** - Default to `hf_jobs(\"uv\", {...})` with inline scripts for Python workloads\n8. **Handle authentication** - Verify tokens are available before Hub operations\n9. **Monitor jobs** - Provide job URLs and status check commands\n10. **Optimize costs** - Choose right hardware, set appropriate timeouts\n\n## Quick Reference: MCP Tool vs CLI vs Python API\n\n| Operation | MCP Tool | CLI | Python API |\n|-----------|----------|-----|------------|\n| Run UV script | `hf_jobs(\"uv\", {...})` | `hf jobs uv run script.py` | `run_uv_job(\"script.py\")` |\n| Run Docker job | `hf_jobs(\"run\", {...})` | `hf jobs run image cmd` | `run_job(image, command)` |\n| List jobs | `hf_jobs(\"ps\")` | `hf jobs ps` | `list_jobs()` |\n| View logs | `hf_jobs(\"logs\", {...})` | `hf jobs logs <id>` | `fetch_job_logs(job_id)` |\n| Cancel job | `hf_jobs(\"cancel\", {...})` | `hf jobs cancel <id>` | `cancel_job(job_id)` |\n| Schedule UV | `hf_jobs(\"scheduled uv\", {...})` | - | `create_scheduled_uv_job()` |\n| Schedule Docker | `hf_jobs(\"scheduled run\", {...})` | - | `create_scheduled_job()` |"
    },
    {
      "id": "huggingface-skills-hugging-face-model-trainer",
      "name": "hugging-face-model-trainer",
      "slug": "hugging-face-model-trainer",
      "description": "This skill should be used when users want to train or fine-tune language models using TRL (Transformer Reinforcement Learning) on Hugging Face Jobs infrastructure. Covers SFT, DPO, GRPO and reward modeling training methods, plus GGUF conversion for local deployment. Includes guidance on the TRL Jobs package, UV scripts with PEP 723 format, dataset preparation and validation, hardware selection, cost estimation, Trackio monitoring, Hub authentication, and model persistence. Should be invoked for tasks involving cloud GPU training, GGUF conversion, or when users mention training on Hugging Face Jobs without local GPU setup.",
      "category": "Git & Workflow",
      "platform": "HuggingFace",
      "platformIcon": "ü§ó",
      "source": "huggingface/skills",
      "sourceUrl": "https://github.com/huggingface/skills/tree/main/skills/hugging-face-model-trainer",
      "skillMdUrl": "https://raw.githubusercontent.com/huggingface/skills/main/skills/hugging-face-model-trainer/SKILL.md",
      "body": "# TRL Training on Hugging Face Jobs\n\n## Overview\n\nTrain language models using TRL (Transformer Reinforcement Learning) on fully managed Hugging Face infrastructure. No local GPU setup required‚Äîmodels train on cloud GPUs and results are automatically saved to the Hugging Face Hub.\n\n**TRL provides multiple training methods:**\n- **SFT** (Supervised Fine-Tuning) - Standard instruction tuning\n- **DPO** (Direct Preference Optimization) - Alignment from preference data\n- **GRPO** (Group Relative Policy Optimization) - Online RL training\n- **Reward Modeling** - Train reward models for RLHF\n\n**For detailed TRL method documentation:**\n```python\nhf_doc_search(\"your query\", product=\"trl\")\nhf_doc_fetch(\"https://huggingface.co/docs/trl/sft_trainer\")  # SFT\nhf_doc_fetch(\"https://huggingface.co/docs/trl/dpo_trainer\")  # DPO\n# etc.\n```\n\n**See also:** `references/training_methods.md` for method overviews and selection guidance\n\n## When to Use This Skill\n\nUse this skill when users want to:\n- Fine-tune language models on cloud GPUs without local infrastructure\n- Train with TRL methods (SFT, DPO, GRPO, etc.)\n- Run training jobs on Hugging Face Jobs infrastructure\n- Convert trained models to GGUF for local deployment (Ollama, LM Studio, llama.cpp)\n- Ensure trained models are permanently saved to the Hub\n- Use modern workflows with optimized defaults\n\n### When to Use Unsloth\n\nUse **Unsloth** (`references/unsloth.md`) instead of standard TRL when:\n- **Limited GPU memory** - Unsloth uses ~60% less VRAM\n- **Speed matters** - Unsloth is ~2x faster\n- Training **large models (>13B)** - memory efficiency is critical\n- Training **Vision-Language Models (VLMs)** - Unsloth has `FastVisionModel` support\n\nSee `references/unsloth.md` for complete Unsloth documentation and `scripts/unsloth_sft_example.py` for a production-ready training script.\n\n## Key Directives\n\nWhen assisting with training jobs:\n\n1. **ALWAYS use `hf_jobs()` MCP tool** - Submit jobs using `hf_jobs(\"uv\", {...})`, NOT bash `trl-jobs` commands. The `script` parameter accepts Python code directly. Do NOT save to local files unless the user explicitly requests it. Pass the script content as a string to `hf_jobs()`. If user asks to \"train a model\", \"fine-tune\", or similar requests, you MUST create the training script AND submit the job immediately using `hf_jobs()`.\n\n2. **Always include Trackio** - Every training script should include Trackio for real-time monitoring. Use example scripts in `scripts/` as templates.\n\n3. **Provide job details after submission** - After submitting, provide job ID, monitoring URL, estimated time, and note that the user can request status checks later.\n\n4. **Use example scripts as templates** - Reference `scripts/train_sft_example.py`, `scripts/train_dpo_example.py`, etc. as starting points.\n\n## Local Script Dependencies\n\nTo run scripts locally (like `estimate_cost.py`), install dependencies:\n```bash\npip install -r requirements.txt\n```\n\n## Prerequisites Checklist\n\nBefore starting any training job, verify:\n\n### ‚úÖ **Account & Authentication**\n- Hugging Face Account with [Pro](https://hf.co/pro), [Team](https://hf.co/enterprise), or [Enterprise](https://hf.co/enterprise) plan (Jobs require paid plan)\n- Authenticated login: Check with `hf_whoami()`\n- **HF_TOKEN for Hub Push** ‚ö†Ô∏è CRITICAL - Training environment is ephemeral, must push to Hub or ALL training results are lost\n- Token must have write permissions  \n- **MUST pass `secrets={\"HF_TOKEN\": \"$HF_TOKEN\"}` in job config** to make token available (the `$HF_TOKEN` syntax\n  references your actual token value)\n\n### ‚úÖ **Dataset Requirements**\n- Dataset must exist on Hub or be loadable via `datasets.load_dataset()`\n- Format must match training method (SFT: \"messages\"/text/prompt-completion; DPO: chosen/rejected; GRPO: prompt-only)\n- **ALWAYS validate unknown datasets** before GPU training to prevent format failures (see Dataset Validation section below)\n- Size appropriate for hardware (Demo: 50-100 examples on t4-small; Production: 1K-10K+ on a10g-large/a100-large)\n\n### ‚ö†Ô∏è **Critical Settings**\n- **Timeout must exceed expected training time** - Default 30min is TOO SHORT for most training. Minimum recommended: 1-2 hours. Job fails and loses all progress if timeout is exceeded.\n- **Hub push must be enabled** - Config: `push_to_hub=True`, `hub_model_id=\"username/model-name\"`; Job: `secrets={\"HF_TOKEN\": \"$HF_TOKEN\"}`\n\n## Asynchronous Job Guidelines\n\n**‚ö†Ô∏è IMPORTANT: Training jobs run asynchronously and can take hours**\n\n### Action Required\n\n**When user requests training:**\n1. **Create the training script** with Trackio included (use `scripts/train_sft_example.py` as template)\n2. **Submit immediately** using `hf_jobs()` MCP tool with script content inline - don't save to file unless user requests\n3. **Report submission** with job ID, monitoring URL, and estimated time\n4. **Wait for user** to request status checks - don't poll automatically\n\n### Ground Rules\n- **Jobs run in background** - Submission returns immediately; training continues independently\n- **Initial logs delayed** - Can take 30-60 seconds for logs to appear\n- **User checks status** - Wait for user to request status updates\n- **Avoid polling** - Check logs only on user request; provide monitoring links instead\n\n### After Submission\n\n**Provide to user:**\n- ‚úÖ Job ID and monitoring URL\n- ‚úÖ Expected completion time\n- ‚úÖ Trackio dashboard URL\n- ‚úÖ Note that user can request status checks later\n\n**Example Response:**\n```\n‚úÖ Job submitted successfully!\n\nJob ID: abc123xyz\nMonitor: https://huggingface.co/jobs/username/abc123xyz\n\nExpected time: ~2 hours\nEstimated cost: ~$10\n\nThe job is running in the background. Ask me to check status/logs when ready!\n```\n\n## Quick Start: Three Approaches\n\n**üí° Tip for Demos:** For quick demos on smaller GPUs (t4-small), omit `eval_dataset` and `eval_strategy` to save ~40% memory. You'll still see training loss and learning progress.\n\n### Sequence Length Configuration\n\n**TRL config classes use `max_length` (not `max_seq_length`)** to control tokenized sequence length:\n\n```python\n# ‚úÖ CORRECT - If you need to set sequence length\nSFTConfig(max_length=512)   # Truncate sequences to 512 tokens\nDPOConfig(max_length=2048)  # Longer context (2048 tokens)\n\n# ‚ùå WRONG - This parameter doesn't exist\nSFTConfig(max_seq_length=512)  # TypeError!\n```\n\n**Default behavior:** `max_length=1024` (truncates from right). This works well for most training.\n\n**When to override:**\n- **Longer context**: Set higher (e.g., `max_length=2048`)\n- **Memory constraints**: Set lower (e.g., `max_length=512`)\n- **Vision models**: Set `max_length=None` (prevents cutting image tokens)\n\n**Usually you don't need to set this parameter at all** - the examples below use the sensible default.\n\n### Approach 1: UV Scripts (Recommended‚ÄîDefault Choice)\n\nUV scripts use PEP 723 inline dependencies for clean, self-contained training. **This is the primary approach for Claude Code.**\n\n```python\nhf_jobs(\"uv\", {\n    \"script\": \"\"\"\n# /// script\n# dependencies = [\"trl>=0.12.0\", \"peft>=0.7.0\", \"trackio\"]\n# ///\n\nfrom datasets import load_dataset\nfrom peft import LoraConfig\nfrom trl import SFTTrainer, SFTConfig\nimport trackio\n\ndataset = load_dataset(\"trl-lib/Capybara\", split=\"train\")\n\n# Create train/eval split for monitoring\ndataset_split = dataset.train_test_split(test_size=0.1, seed=42)\n\ntrainer = SFTTrainer(\n    model=\"Qwen/Qwen2.5-0.5B\",\n    train_dataset=dataset_split[\"train\"],\n    eval_dataset=dataset_split[\"test\"],\n    peft_config=LoraConfig(r=16, lora_alpha=32),\n    args=SFTConfig(\n        output_dir=\"my-model\",\n        push_to_hub=True,\n        hub_model_id=\"username/my-model\",\n        num_train_epochs=3,\n        eval_strategy=\"steps\",\n        eval_steps=50,\n        report_to=\"trackio\",\n        project=\"meaningful_prject_name\", # project name for the training name (trackio)\n        run_name=\"meaningful_run_name\",   # descriptive name for the specific training run (trackio)\n    )\n)\n\ntrainer.train()\ntrainer.push_to_hub()\n\"\"\",\n    \"flavor\": \"a10g-large\",\n    \"timeout\": \"2h\",\n    \"secrets\": {\"HF_TOKEN\": \"$HF_TOKEN\"}\n})\n```\n\n**Benefits:** Direct MCP tool usage, clean code, dependencies declared inline (PEP 723), no file saving required, full control\n**When to use:** Default choice for all training tasks in Claude Code, custom training logic, any scenario requiring `hf_jobs()`\n\n#### Working with Scripts\n\n‚ö†Ô∏è **Important:** The `script` parameter accepts either inline code (as shown above) OR a URL. **Local file paths do NOT work.**\n\n**Why local paths don't work:**\nJobs run in isolated Docker containers without access to your local filesystem. Scripts must be:\n- Inline code (recommended for custom training)\n- Publicly accessible URLs\n- Private repo URLs (with HF_TOKEN)\n\n**Common mistakes:**\n```python\n# ‚ùå These will all fail\nhf_jobs(\"uv\", {\"script\": \"train.py\"})\nhf_jobs(\"uv\", {\"script\": \"./scripts/train.py\"})\nhf_jobs(\"uv\", {\"script\": \"/path/to/train.py\"})\n```\n\n**Correct approaches:**\n```python\n# ‚úÖ Inline code (recommended)\nhf_jobs(\"uv\", {\"script\": \"# /// script\\n# dependencies = [...]\\n# ///\\n\\n<your code>\"})\n\n# ‚úÖ From Hugging Face Hub\nhf_jobs(\"uv\", {\"script\": \"https://huggingface.co/user/repo/resolve/main/train.py\"})\n\n# ‚úÖ From GitHub\nhf_jobs(\"uv\", {\"script\": \"https://raw.githubusercontent.com/user/repo/main/train.py\"})\n\n# ‚úÖ From Gist\nhf_jobs(\"uv\", {\"script\": \"https://gist.githubusercontent.com/user/id/raw/train.py\"})\n```\n\n**To use local scripts:** Upload to HF Hub first:\n```bash\nhuggingface-cli repo create my-training-scripts --type model\nhuggingface-cli upload my-training-scripts ./train.py train.py\n# Use: https://huggingface.co/USERNAME/my-training-scripts/resolve/main/train.py\n```\n\n### Approach 2: TRL Maintained Scripts (Official Examples)\n\nTRL provides battle-tested scripts for all methods. Can be run from URLs:\n\n```python\nhf_jobs(\"uv\", {\n    \"script\": \"https://github.com/huggingface/trl/blob/main/trl/scripts/sft.py\",\n    \"script_args\": [\n        \"--model_name_or_path\", \"Qwen/Qwen2.5-0.5B\",\n        \"--dataset_name\", \"trl-lib/Capybara\",\n        \"--output_dir\", \"my-model\",\n        \"--push_to_hub\",\n        \"--hub_model_id\", \"username/my-model\"\n    ],\n    \"flavor\": \"a10g-large\",\n    \"timeout\": \"2h\",\n    \"secrets\": {\"HF_TOKEN\": \"$HF_TOKEN\"}\n})\n```\n\n**Benefits:** No code to write, maintained by TRL team, production-tested\n**When to use:** Standard TRL training, quick experiments, don't need custom code\n**Available:** Scripts are available from https://github.com/huggingface/trl/tree/main/examples/scripts\n\n### Finding More UV Scripts on Hub\n\nThe `uv-scripts` organization provides ready-to-use UV scripts stored as datasets on Hugging Face Hub:\n\n```python\n# Discover available UV script collections\ndataset_search({\"author\": \"uv-scripts\", \"sort\": \"downloads\", \"limit\": 20})\n\n# Explore a specific collection\nhub_repo_details([\"uv-scripts/classification\"], repo_type=\"dataset\", include_readme=True)\n```\n\n**Popular collections:** ocr, classification, synthetic-data, vllm, dataset-creation\n\n### Approach 3: HF Jobs CLI (Direct Terminal Commands)\n\nWhen the `hf_jobs()` MCP tool is unavailable, use the `hf jobs` CLI directly.\n\n**‚ö†Ô∏è CRITICAL: CLI Syntax Rules**\n\n```bash\n# ‚úÖ CORRECT syntax - flags BEFORE script URL\nhf jobs uv run --flavor a10g-large --timeout 2h --secrets HF_TOKEN \"https://example.com/train.py\"\n\n# ‚ùå WRONG - \"run uv\" instead of \"uv run\"\nhf jobs run uv \"https://example.com/train.py\" --flavor a10g-large\n\n# ‚ùå WRONG - flags AFTER script URL (will be ignored!)\nhf jobs uv run \"https://example.com/train.py\" --flavor a10g-large\n\n# ‚ùå WRONG - \"--secret\" instead of \"--secrets\" (plural)\nhf jobs uv run --secret HF_TOKEN \"https://example.com/train.py\"\n```\n\n**Key syntax rules:**\n1. Command order is `hf jobs uv run` (NOT `hf jobs run uv`)\n2. All flags (`--flavor`, `--timeout`, `--secrets`) must come BEFORE the script URL\n3. Use `--secrets` (plural), not `--secret`\n4. Script URL must be the last positional argument\n\n**Complete CLI example:**\n```bash\nhf jobs uv run \\\n  --flavor a10g-large \\\n  --timeout 2h \\\n  --secrets HF_TOKEN \\\n  \"https://huggingface.co/user/repo/resolve/main/train.py\"\n```\n\n**Check job status via CLI:**\n```bash\nhf jobs ps                        # List all jobs\nhf jobs logs <job-id>             # View logs\nhf jobs inspect <job-id>          # Job details\nhf jobs cancel <job-id>           # Cancel a job\n```\n\n### Approach 4: TRL Jobs Package (Simplified Training)\n\nThe `trl-jobs` package provides optimized defaults and one-liner training.\n\n```bash\n# Install\npip install trl-jobs\n\n# Train with SFT (simplest possible)\ntrl-jobs sft \\\n  --model_name Qwen/Qwen2.5-0.5B \\\n  --dataset_name trl-lib/Capybara\n```\n\n**Benefits:** Pre-configured settings, automatic Trackio integration, automatic Hub push, one-line commands\n**When to use:** User working in terminal directly (not Claude Code context), quick local experimentation\n**Repository:** https://github.com/huggingface/trl-jobs\n\n‚ö†Ô∏è **In Claude Code context, prefer using `hf_jobs()` MCP tool (Approach 1) when available.**\n\n## Hardware Selection\n\n| Model Size | Recommended Hardware | Cost (approx/hr) | Use Case |\n|------------|---------------------|------------------|----------|\n| <1B params | `t4-small` | ~$0.75 | Demos, quick tests only without eval steps |\n| 1-3B params | `t4-medium`, `l4x1` | ~$1.50-2.50 | Development |\n| 3-7B params | `a10g-small`, `a10g-large` | ~$3.50-5.00 | Production training |\n| 7-13B params | `a10g-large`, `a100-large` | ~$5-10 | Large models (use LoRA) |\n| 13B+ params | `a100-large`, `a10g-largex2` | ~$10-20 | Very large (use LoRA) |\n\n**GPU Flavors:** cpu-basic/upgrade/performance/xl, t4-small/medium, l4x1/x4, a10g-small/large/largex2/largex4, a100-large, h100/h100x8\n\n**Guidelines:**\n- Use **LoRA/PEFT** for models >7B to reduce memory\n- Multi-GPU automatically handled by TRL/Accelerate\n- Start with smaller hardware for testing\n\n**See:** `references/hardware_guide.md` for detailed specifications\n\n## Critical: Saving Results to Hub\n\n**‚ö†Ô∏è EPHEMERAL ENVIRONMENT‚ÄîMUST PUSH TO HUB**\n\nThe Jobs environment is temporary. All files are deleted when the job ends. If the model isn't pushed to Hub, **ALL TRAINING IS LOST**.\n\n### Required Configuration\n\n**In training script/config:**\n```python\nSFTConfig(\n    push_to_hub=True,\n    hub_model_id=\"username/model-name\",  # MUST specify\n    hub_strategy=\"every_save\",  # Optional: push checkpoints\n)\n```\n\n**In job submission:**\n```python\n{\n    \"secrets\": {\"HF_TOKEN\": \"$HF_TOKEN\"}  # Enables authentication\n}\n```\n\n### Verification Checklist\n\nBefore submitting:\n- [ ] `push_to_hub=True` set in config\n- [ ] `hub_model_id` includes username/repo-name\n- [ ] `secrets` parameter includes HF_TOKEN\n- [ ] User has write access to target repo\n\n**See:** `references/hub_saving.md` for detailed troubleshooting\n\n## Timeout Management\n\n**‚ö†Ô∏è DEFAULT: 30 MINUTES‚ÄîTOO SHORT FOR TRAINING**\n\n### Setting Timeouts\n\n```python\n{\n    \"timeout\": \"2h\"   # 2 hours (formats: \"90m\", \"2h\", \"1.5h\", or seconds as integer)\n}\n```\n\n### Timeout Guidelines\n\n| Scenario | Recommended | Notes |\n|----------|-------------|-------|\n| Quick demo (50-100 examples) | 10-30 min | Verify setup |\n| Development training | 1-2 hours | Small datasets |\n| Production (3-7B model) | 4-6 hours | Full datasets |\n| Large model with LoRA | 3-6 hours | Depends on dataset |\n\n**Always add 20-30% buffer** for model/dataset loading, checkpoint saving, Hub push operations, and network delays.\n\n**On timeout:** Job killed immediately, all unsaved progress lost, must restart from beginning\n\n## Cost Estimation\n\n**Offer to estimate cost when planning jobs with known parameters.** Use `scripts/estimate_cost.py`:\n\n```bash\nuv run scripts/estimate_cost.py \\\n  --model meta-llama/Llama-2-7b-hf \\\n  --dataset trl-lib/Capybara \\\n  --hardware a10g-large \\\n  --dataset-size 16000 \\\n  --epochs 3\n```\n\nOutput includes estimated time, cost, recommended timeout (with buffer), and optimization suggestions.\n\n**When to offer:** User planning a job, asks about cost/time, choosing hardware, job will run >1 hour or cost >$5\n\n## Example Training Scripts\n\n**Production-ready templates with all best practices:**\n\nLoad these scripts for correctly:\n\n- **`scripts/train_sft_example.py`** - Complete SFT training with Trackio, LoRA, checkpoints\n- **`scripts/train_dpo_example.py`** - DPO training for preference learning\n- **`scripts/train_grpo_example.py`** - GRPO training for online RL\n\nThese scripts demonstrate proper Hub saving, Trackio integration, checkpoint management, and optimized parameters. Pass their content inline to `hf_jobs()` or use as templates for custom scripts.\n\n## Monitoring and Tracking\n\n**Trackio** provides real-time metrics visualization. See `references/trackio_guide.md` for complete setup guide.\n\n**Key points:**\n- Add `trackio` to dependencies\n- Configure trainer with `report_to=\"trackio\" and run_name=\"meaningful_name\"`\n\n### Trackio Configuration Defaults\n\n**Use sensible defaults unless user specifies otherwise.** When generating training scripts with Trackio:\n\n**Default Configuration:**\n- **Space ID**: `{username}/trackio` (use \"trackio\" as default space name)\n- **Run naming**: Unless otherwise specified, name the run in a way the user will recognize (e.g., descriptive of the task, model, or purpose)\n- **Config**: Keep minimal - only include hyperparameters and model/dataset info\n- **Project Name**: Use a Project Name to associate runs with a particular Project \n\n**User overrides:** If user requests specific trackio configuration (custom space, run naming, grouping, or additional config), apply their preferences instead of defaults.\n\n\nThis is useful for managing multiple jobs with the same configuration or keeping training scripts portable.\n\nSee `references/trackio_guide.md` for complete documentation including grouping runs for experiments.\n\n### Check Job Status\n\n```python\n# List all jobs\nhf_jobs(\"ps\")\n\n# Inspect specific job\nhf_jobs(\"inspect\", {\"job_id\": \"your-job-id\"})\n\n# View logs\nhf_jobs(\"logs\", {\"job_id\": \"your-job-id\"})\n```\n\n**Remember:** Wait for user to request status checks. Avoid polling repeatedly.\n\n## Dataset Validation\n\n**Validate dataset format BEFORE launching GPU training to prevent the #1 cause of training failures: format mismatches.**\n\n### Why Validate\n\n- 50%+ of training failures are due to dataset format issues\n- DPO especially strict: requires exact column names (`prompt`, `chosen`, `rejected`)\n- Failed GPU jobs waste $1-10 and 30-60 minutes\n- Validation on CPU costs ~$0.01 and takes <1 minute\n\n### When to Validate\n\n**ALWAYS validate for:**\n- Unknown or custom datasets\n- DPO training (CRITICAL - 90% of datasets need mapping)\n- Any dataset not explicitly TRL-compatible\n\n**Skip validation for known TRL datasets:**\n- `trl-lib/ultrachat_200k`, `trl-lib/Capybara`, `HuggingFaceH4/ultrachat_200k`, etc.\n\n### Usage\n\n```python\nhf_jobs(\"uv\", {\n    \"script\": \"https://huggingface.co/datasets/mcp-tools/skills/raw/main/dataset_inspector.py\",\n    \"script_args\": [\"--dataset\", \"username/dataset-name\", \"--split\", \"train\"]\n})\n```\n\nThe script is fast, and will usually complete synchronously.\n\n### Reading Results\n\nThe output shows compatibility for each training method:\n\n- **`‚úì READY`** - Dataset is compatible, use directly\n- **`‚úó NEEDS MAPPING`** - Compatible but needs preprocessing (mapping code provided)\n- **`‚úó INCOMPATIBLE`** - Cannot be used for this method\n\nWhen mapping is needed, the output includes a **\"MAPPING CODE\"** section with copy-paste ready Python code.\n\n### Example Workflow\n\n```python\n# 1. Inspect dataset (costs ~$0.01, <1 min on CPU)\nhf_jobs(\"uv\", {\n    \"script\": \"https://huggingface.co/datasets/mcp-tools/skills/raw/main/dataset_inspector.py\",\n    \"script_args\": [\"--dataset\", \"argilla/distilabel-math-preference-dpo\", \"--split\", \"train\"]\n})\n\n# 2. Check output markers:\n#    ‚úì READY ‚Üí proceed with training\n#    ‚úó NEEDS MAPPING ‚Üí apply mapping code below\n#    ‚úó INCOMPATIBLE ‚Üí choose different method/dataset\n\n# 3. If mapping needed, apply before training:\ndef format_for_dpo(example):\n    return {\n        'prompt': example['instruction'],\n        'chosen': example['chosen_response'],\n        'rejected': example['rejected_response'],\n    }\ndataset = dataset.map(format_for_dpo, remove_columns=dataset.column_names)\n\n# 4. Launch training job with confidence\n```\n\n### Common Scenario: DPO Format Mismatch\n\nMost DPO datasets use non-standard column names. Example:\n\n```\nDataset has: instruction, chosen_response, rejected_response\nDPO expects: prompt, chosen, rejected\n```\n\nThe validator detects this and provides exact mapping code to fix it.\n\n## Converting Models to GGUF\n\nAfter training, convert models to **GGUF format** for use with llama.cpp, Ollama, LM Studio, and other local inference tools.\n\n**What is GGUF:**\n- Optimized for CPU/GPU inference with llama.cpp\n- Supports quantization (4-bit, 5-bit, 8-bit) to reduce model size\n- Compatible with Ollama, LM Studio, Jan, GPT4All, llama.cpp\n- Typically 2-8GB for 7B models (vs 14GB unquantized)\n\n**When to convert:**\n- Running models locally with Ollama or LM Studio\n- Reducing model size with quantization\n- Deploying to edge devices\n- Sharing models for local-first use\n\n**See:** `references/gguf_conversion.md` for complete conversion guide, including production-ready conversion script, quantization options, hardware requirements, usage examples, and troubleshooting.\n\n**Quick conversion:**\n```python\nhf_jobs(\"uv\", {\n    \"script\": \"<see references/gguf_conversion.md for complete script>\",\n    \"flavor\": \"a10g-large\",\n    \"timeout\": \"45m\",\n    \"secrets\": {\"HF_TOKEN\": \"$HF_TOKEN\"},\n    \"env\": {\n        \"ADAPTER_MODEL\": \"username/my-finetuned-model\",\n        \"BASE_MODEL\": \"Qwen/Qwen2.5-0.5B\",\n        \"OUTPUT_REPO\": \"username/my-model-gguf\"\n    }\n})\n```\n\n## Common Training Patterns\n\nSee `references/training_patterns.md` for detailed examples including:\n- Quick demo (5-10 minutes)\n- Production with checkpoints\n- Multi-GPU training\n- DPO training (preference learning)\n- GRPO training (online RL)\n\n## Common Failure Modes\n\n### Out of Memory (OOM)\n\n**Fix (try in order):**\n1. Reduce batch size: `per_device_train_batch_size=1`, increase `gradient_accumulation_steps=8`. Effective batch size is `per_device_train_batch_size` x `gradient_accumulation_steps`. For best performance keep effective batch size close to 128. \n2. Enable: `gradient_checkpointing=True`\n3. Upgrade hardware: t4-small ‚Üí l4x1, a10g-small ‚Üí a10g-large etc. \n\n### Dataset Misformatted\n\n**Fix:**\n1. Validate first with dataset inspector:\n   ```bash\n   uv run https://huggingface.co/datasets/mcp-tools/skills/raw/main/dataset_inspector.py \\\n     --dataset name --split train\n   ```\n2. Check output for compatibility markers (‚úì READY, ‚úó NEEDS MAPPING, ‚úó INCOMPATIBLE)\n3. Apply mapping code from inspector output if needed\n\n### Job Timeout\n\n**Fix:**\n1. Check logs for actual runtime: `hf_jobs(\"logs\", {\"job_id\": \"...\"})`\n2. Increase timeout with buffer: `\"timeout\": \"3h\"` (add 30% to estimated time)\n3. Or reduce training: lower `num_train_epochs`, use smaller dataset, enable `max_steps`\n4. Save checkpoints: `save_strategy=\"steps\"`, `save_steps=500`, `hub_strategy=\"every_save\"`\n\n**Note:** Default 30min is insufficient for real training. Minimum 1-2 hours.\n\n### Hub Push Failures\n\n**Fix:**\n1. Add to job: `secrets={\"HF_TOKEN\": \"$HF_TOKEN\"}`\n2. Add to config: `push_to_hub=True`, `hub_model_id=\"username/model-name\"`\n3. Verify auth: `mcp__huggingface__hf_whoami()`\n4. Check token has write permissions and repo exists (or set `hub_private_repo=True`)\n\n### Missing Dependencies\n\n**Fix:**\nAdd to PEP 723 header:\n```python\n# /// script\n# dependencies = [\"trl>=0.12.0\", \"peft>=0.7.0\", \"trackio\", \"missing-package\"]\n# ///\n```\n\n## Troubleshooting\n\n**Common issues:**\n- Job times out ‚Üí Increase timeout, reduce epochs/dataset, use smaller model/LoRA\n- Model not saved to Hub ‚Üí Check push_to_hub=True, hub_model_id, secrets=HF_TOKEN\n- Out of Memory (OOM) ‚Üí Reduce batch size, increase gradient accumulation, enable LoRA, use larger GPU\n- Dataset format error ‚Üí Validate with dataset inspector (see Dataset Validation section)\n- Import/module errors ‚Üí Add PEP 723 header with dependencies, verify format\n- Authentication errors ‚Üí Check `mcp__huggingface__hf_whoami()`, token permissions, secrets parameter\n\n**See:** `references/troubleshooting.md` for complete troubleshooting guide\n\n## Resources\n\n### References (In This Skill)\n- `references/training_methods.md` - Overview of SFT, DPO, GRPO, KTO, PPO, Reward Modeling\n- `references/training_patterns.md` - Common training patterns and examples\n- `references/unsloth.md` - Unsloth for fast VLM training (~2x speed, 60% less VRAM)\n- `references/gguf_conversion.md` - Complete GGUF conversion guide\n- `references/trackio_guide.md` - Trackio monitoring setup\n- `references/hardware_guide.md` - Hardware specs and selection\n- `references/hub_saving.md` - Hub authentication troubleshooting\n- `references/troubleshooting.md` - Common issues and solutions\n\n### Scripts (In This Skill)\n- `scripts/train_sft_example.py` - Production SFT template\n- `scripts/train_dpo_example.py` - Production DPO template\n- `scripts/train_grpo_example.py` - Production GRPO template\n- `scripts/unsloth_sft_example.py` - Unsloth text LLM training template (faster, less VRAM)\n- `scripts/estimate_cost.py` - Estimate time and cost (offer when appropriate)\n- `scripts/convert_to_gguf.py` - Complete GGUF conversion script\n\n### External Scripts\n- [Dataset Inspector](https://huggingface.co/datasets/mcp-tools/skills/raw/main/dataset_inspector.py) - Validate dataset format before training (use via `uv run` or `hf_jobs`)\n\n### External Links\n- [TRL Documentation](https://huggingface.co/docs/trl)\n- [TRL Jobs Training Guide](https://huggingface.co/docs/trl/en/jobs_training)\n- [TRL Jobs Package](https://github.com/huggingface/trl-jobs)\n- [HF Jobs Documentation](https://huggingface.co/docs/huggingface_hub/guides/jobs)\n- [TRL Example Scripts](https://github.com/huggingface/trl/tree/main/examples/scripts)\n- [UV Scripts Guide](https://docs.astral.sh/uv/guides/scripts/)\n- [UV Scripts Organization](https://huggingface.co/uv-scripts)\n\n## Key Takeaways\n\n1. **Submit scripts inline** - The `script` parameter accepts Python code directly; no file saving required unless user requests\n2. **Jobs are asynchronous** - Don't wait/poll; let user check when ready\n3. **Always set timeout** - Default 30 min is insufficient; minimum 1-2 hours recommended\n4. **Always enable Hub push** - Environment is ephemeral; without push, all results lost\n5. **Include Trackio** - Use example scripts as templates for real-time monitoring\n6. **Offer cost estimation** - When parameters are known, use `scripts/estimate_cost.py`\n7. **Use UV scripts (Approach 1)** - Default to `hf_jobs(\"uv\", {...})` with inline scripts; TRL maintained scripts for standard training; avoid bash `trl-jobs` commands in Claude Code\n8. **Use hf_doc_fetch/hf_doc_search** for latest TRL documentation\n9. **Validate dataset format** before training with dataset inspector (see Dataset Validation section)\n10. **Choose appropriate hardware** for model size; use LoRA for models >7B"
    },
    {
      "id": "huggingface-skills-hugging-face-paper-publisher",
      "name": "hugging-face-paper-publisher",
      "slug": "hugging-face-paper-publisher",
      "description": "Publish and manage research papers on Hugging Face Hub. Supports creating paper pages, linking papers to models/datasets, claiming authorship, and generating professional markdown-based research articles.",
      "category": "Git & Workflow",
      "platform": "HuggingFace",
      "platformIcon": "ü§ó",
      "source": "huggingface/skills",
      "sourceUrl": "https://github.com/huggingface/skills/tree/main/skills/hugging-face-paper-publisher",
      "skillMdUrl": "https://raw.githubusercontent.com/huggingface/skills/main/skills/hugging-face-paper-publisher/SKILL.md",
      "body": "# Overview\nThis skill provides comprehensive tools for AI engineers and researchers to publish, manage, and link research papers on the Hugging Face Hub. It streamlines the workflow from paper creation to publication, including integration with arXiv, model/dataset linking, and authorship management.\n\n## Integration with HF Ecosystem\n- **Paper Pages**: Index and discover papers on Hugging Face Hub\n- **arXiv Integration**: Automatic paper indexing from arXiv IDs\n- **Model/Dataset Linking**: Connect papers to relevant artifacts through metadata\n- **Authorship Verification**: Claim and verify paper authorship\n- **Research Article Template**: Generate professional, modern scientific papers\n\n# Version\n1.0.0\n\n# Dependencies\n- huggingface_hub>=0.26.0\n- pyyaml>=6.0.3\n- requests>=2.32.5\n- markdown>=3.5.0\n- python-dotenv>=1.2.1\n\n# Core Capabilities\n\n## 1. Paper Page Management\n- **Index Papers**: Add papers to Hugging Face from arXiv\n- **Claim Authorship**: Verify and claim authorship on published papers\n- **Manage Visibility**: Control which papers appear on your profile\n- **Paper Discovery**: Find and explore papers in the HF ecosystem\n\n## 2. Link Papers to Artifacts\n- **Model Cards**: Add paper citations to model metadata\n- **Dataset Cards**: Link papers to datasets via README\n- **Automatic Tagging**: Hub auto-generates arxiv:<PAPER_ID> tags\n- **Citation Management**: Maintain proper attribution and references\n\n## 3. Research Article Creation\n- **Markdown Templates**: Generate professional paper formatting\n- **Modern Design**: Clean, readable research article layouts\n- **Dynamic TOC**: Automatic table of contents generation\n- **Section Structure**: Standard scientific paper organization\n- **LaTeX Math**: Support for equations and technical notation\n\n## 4. Metadata Management\n- **YAML Frontmatter**: Proper model/dataset card metadata\n- **Citation Tracking**: Maintain paper references across repositories\n- **Version Control**: Track paper updates and revisions\n- **Multi-Paper Support**: Link multiple papers to single artifacts\n\n# Usage Instructions\n\nThe skill includes Python scripts in `scripts/` for paper publishing operations.\n\n### Prerequisites\n- Install dependencies: `uv add huggingface_hub pyyaml requests markdown python-dotenv`\n- Set `HF_TOKEN` environment variable with Write-access token\n- Activate virtual environment: `source .venv/bin/activate`\n\n> **All paths are relative to the directory containing this SKILL.md\nfile.**\n> Before running any script, first `cd` to that directory or use the full\npath.\n\n\n### Method 1: Index Paper from arXiv\n\nAdd a paper to Hugging Face Paper Pages from arXiv.\n\n**Basic Usage:**\n```bash\nuv run scripts/paper_manager.py index \\\n  --arxiv-id \"2301.12345\"\n```\n\n**Check If Paper Exists:**\n```bash\nuv run scripts/paper_manager.py check \\\n  --arxiv-id \"2301.12345\"\n```\n\n**Direct URL Access:**\nYou can also visit `https://huggingface.co/papers/{arxiv-id}` directly to index a paper.\n\n### Method 2: Link Paper to Model/Dataset\n\nAdd paper references to model or dataset README with proper YAML metadata.\n\n**Add to Model Card:**\n```bash\nuv run scripts/paper_manager.py link \\\n  --repo-id \"username/model-name\" \\\n  --repo-type \"model\" \\\n  --arxiv-id \"2301.12345\"\n```\n\n**Add to Dataset Card:**\n```bash\nuv run scripts/paper_manager.py link \\\n  --repo-id \"username/dataset-name\" \\\n  --repo-type \"dataset\" \\\n  --arxiv-id \"2301.12345\"\n```\n\n**Add Multiple Papers:**\n```bash\nuv run scripts/paper_manager.py link \\\n  --repo-id \"username/model-name\" \\\n  --repo-type \"model\" \\\n  --arxiv-ids \"2301.12345,2302.67890,2303.11111\"\n```\n\n**With Custom Citation:**\n```bash\nuv run scripts/paper_manager.py link \\\n  --repo-id \"username/model-name\" \\\n  --repo-type \"model\" \\\n  --arxiv-id \"2301.12345\" \\\n  --citation \"$(cat citation.txt)\"\n```\n\n#### How Linking Works\n\nWhen you add an arXiv paper link to a model or dataset README:\n1. The Hub extracts the arXiv ID from the link\n2. A tag `arxiv:<PAPER_ID>` is automatically added to the repository\n3. Users can click the tag to view the Paper Page\n4. The Paper Page shows all models/datasets citing this paper\n5. Papers are discoverable through filters and search\n\n### Method 3: Claim Authorship\n\nVerify your authorship on papers published on Hugging Face.\n\n**Start Claim Process:**\n```bash\nuv run scripts/paper_manager.py claim \\\n  --arxiv-id \"2301.12345\" \\\n  --email \"your.email@institution.edu\"\n```\n\n**Manual Process:**\n1. Navigate to your paper's page: `https://huggingface.co/papers/{arxiv-id}`\n2. Find your name in the author list\n3. Click your name and select \"Claim authorship\"\n4. Wait for admin team verification\n\n**Check Authorship Status:**\n```bash\nuv run scripts/paper_manager.py check-authorship \\\n  --arxiv-id \"2301.12345\"\n```\n\n### Method 4: Manage Paper Visibility\n\nControl which verified papers appear on your public profile.\n\n**List Your Papers:**\n```bash\nuv run scripts/paper_manager.py list-my-papers\n```\n\n**Toggle Visibility:**\n```bash\nuv run scripts/paper_manager.py toggle-visibility \\\n  --arxiv-id \"2301.12345\" \\\n  --show true\n```\n\n**Manage in Settings:**\nNavigate to your account settings ‚Üí Papers section to toggle \"Show on profile\" for each paper.\n\n### Method 5: Create Research Article\n\nGenerate a professional markdown-based research paper using modern templates.\n\n**Create from Template:**\n```bash\nuv run scripts/paper_manager.py create \\\n  --template \"standard\" \\\n  --title \"Your Paper Title\" \\\n  --output \"paper.md\"\n```\n\n**Available Templates:**\n- `standard` - Traditional scientific paper structure\n- `modern` - Clean, web-friendly format inspired by Distill\n- `arxiv` - arXiv-style formatting\n- `ml-report` - Machine learning experiment report\n\n**Generate Complete Paper:**\n```bash\nuv run scripts/paper_manager.py create \\\n  --template \"modern\" \\\n  --title \"Fine-Tuning Large Language Models with LoRA\" \\\n  --authors \"Jane Doe, John Smith\" \\\n  --abstract \"$(cat abstract.txt)\" \\\n  --output \"paper.md\"\n```\n\n**Convert to HTML:**\n```bash\nuv run scripts/paper_manager.py convert \\\n  --input \"paper.md\" \\\n  --output \"paper.html\" \\\n  --style \"modern\"\n```\n\n### Paper Template Structure\n\n**Standard Research Paper Sections:**\n```markdown\n---\ntitle: Your Paper Title\nauthors: Jane Doe, John Smith\naffiliations: University X, Lab Y\ndate: 2025-01-15\narxiv: 2301.12345\ntags: [machine-learning, nlp, fine-tuning]\n---\n\n# Abstract\nBrief summary of the paper...\n\n# 1. Introduction\nBackground and motivation...\n\n# 2. Related Work\nPrevious research and context...\n\n# 3. Methodology\nApproach and implementation...\n\n# 4. Experiments\nSetup, datasets, and procedures...\n\n# 5. Results\nFindings and analysis...\n\n# 6. Discussion\nInterpretation and implications...\n\n# 7. Conclusion\nSummary and future work...\n\n# References\n```\n\n**Modern Template Features:**\n- Dynamic table of contents\n- Responsive design for web viewing\n- Code syntax highlighting\n- Interactive figures and charts\n- Math equation rendering (LaTeX)\n- Citation management\n- Author affiliation linking\n\n### Commands Reference\n\n**Index Paper:**\n```bash\nuv run scripts/paper_manager.py index --arxiv-id \"2301.12345\"\n```\n\n**Link to Repository:**\n```bash\nuv run scripts/paper_manager.py link \\\n  --repo-id \"username/repo-name\" \\\n  --repo-type \"model|dataset|space\" \\\n  --arxiv-id \"2301.12345\" \\\n  [--citation \"Full citation text\"] \\\n  [--create-pr]\n```\n\n**Claim Authorship:**\n```bash\nuv run scripts/paper_manager.py claim \\\n  --arxiv-id \"2301.12345\" \\\n  --email \"your.email@edu\"\n```\n\n**Manage Visibility:**\n```bash\nuv run scripts/paper_manager.py toggle-visibility \\\n  --arxiv-id \"2301.12345\" \\\n  --show true|false\n```\n\n**Create Research Article:**\n```bash\nuv run scripts/paper_manager.py create \\\n  --template \"standard|modern|arxiv|ml-report\" \\\n  --title \"Paper Title\" \\\n  [--authors \"Author1, Author2\"] \\\n  [--abstract \"Abstract text\"] \\\n  [--output \"filename.md\"]\n```\n\n**Convert Markdown to HTML:**\n```bash\nuv run scripts/paper_manager.py convert \\\n  --input \"paper.md\" \\\n  --output \"paper.html\" \\\n  [--style \"modern|classic\"]\n```\n\n**Check Paper Status:**\n```bash\nuv run scripts/paper_manager.py check --arxiv-id \"2301.12345\"\n```\n\n**List Your Papers:**\n```bash\nuv run scripts/paper_manager.py list-my-papers\n```\n\n**Search Papers:**\n```bash\nuv run scripts/paper_manager.py search --query \"transformer attention\"\n```\n\n### YAML Metadata Format\n\nWhen linking papers to models or datasets, proper YAML frontmatter is required:\n\n**Model Card Example:**\n```yaml\n---\nlanguage:\n  - en\nlicense: apache-2.0\ntags:\n  - text-generation\n  - transformers\n  - llm\nlibrary_name: transformers\n---\n\n# Model Name\n\nThis model is based on the approach described in [Our Paper](https://arxiv.org/abs/2301.12345).\n\n## Citation\n\n```bibtex\n@article{doe2023paper,\n  title={Your Paper Title},\n  author={Doe, Jane and Smith, John},\n  journal={arXiv preprint arXiv:2301.12345},\n  year={2023}\n}\n```\n```\n\n**Dataset Card Example:**\n```yaml\n---\nlanguage:\n  - en\nlicense: cc-by-4.0\ntask_categories:\n  - text-generation\n  - question-answering\nsize_categories:\n  - 10K<n<100K\n---\n\n# Dataset Name\n\nDataset introduced in [Our Paper](https://arxiv.org/abs/2301.12345).\n\nFor more details, see the [paper page](https://huggingface.co/papers/2301.12345).\n```\n\nThe Hub automatically extracts arXiv IDs from these links and creates `arxiv:2301.12345` tags.\n\n### Integration Examples\n\n**Workflow 1: Publish New Research**\n```bash\n# 1. Create research article\nuv run scripts/paper_manager.py create \\\n  --template \"modern\" \\\n  --title \"Novel Fine-Tuning Approach\" \\\n  --output \"paper.md\"\n\n# 2. Edit paper.md with your content\n\n# 3. Submit to arXiv (external process)\n# Upload to arxiv.org, get arXiv ID\n\n# 4. Index on Hugging Face\nuv run scripts/paper_manager.py index --arxiv-id \"2301.12345\"\n\n# 5. Link to your model\nuv run scripts/paper_manager.py link \\\n  --repo-id \"your-username/your-model\" \\\n  --repo-type \"model\" \\\n  --arxiv-id \"2301.12345\"\n\n# 6. Claim authorship\nuv run scripts/paper_manager.py claim \\\n  --arxiv-id \"2301.12345\" \\\n  --email \"your.email@edu\"\n```\n\n**Workflow 2: Link Existing Paper**\n```bash\n# 1. Check if paper exists\nuv run scripts/paper_manager.py check --arxiv-id \"2301.12345\"\n\n# 2. Index if needed\nuv run scripts/paper_manager.py index --arxiv-id \"2301.12345\"\n\n# 3. Link to multiple repositories\nuv run scripts/paper_manager.py link \\\n  --repo-id \"username/model-v1\" \\\n  --repo-type \"model\" \\\n  --arxiv-id \"2301.12345\"\n\nuv run scripts/paper_manager.py link \\\n  --repo-id \"username/training-data\" \\\n  --repo-type \"dataset\" \\\n  --arxiv-id \"2301.12345\"\n\nuv run scripts/paper_manager.py link \\\n  --repo-id \"username/demo-space\" \\\n  --repo-type \"space\" \\\n  --arxiv-id \"2301.12345\"\n```\n\n**Workflow 3: Update Model with Paper Reference**\n```bash\n# 1. Get current README\nhuggingface-cli download username/model-name README.md\n\n# 2. Add paper link\nuv run scripts/paper_manager.py link \\\n  --repo-id \"username/model-name\" \\\n  --repo-type \"model\" \\\n  --arxiv-id \"2301.12345\" \\\n  --citation \"Full citation for the paper\"\n\n# The script will:\n# - Add YAML metadata if missing\n# - Insert arXiv link in README\n# - Add formatted citation\n# - Preserve existing content\n```\n\n### Best Practices\n\n1. **Paper Indexing**\n   - Index papers as soon as they're published on arXiv\n   - Include full citation information in model/dataset cards\n   - Use consistent paper references across related repositories\n\n2. **Metadata Management**\n   - Add YAML frontmatter to all model/dataset cards\n   - Include proper licensing information\n   - Tag with relevant task categories and domains\n\n3. **Authorship**\n   - Claim authorship on papers where you're listed as author\n   - Use institutional email addresses for verification\n   - Keep paper visibility settings updated\n\n4. **Repository Linking**\n   - Link papers to all relevant models, datasets, and Spaces\n   - Include paper context in README descriptions\n   - Add BibTeX citations for easy reference\n\n5. **Research Articles**\n   - Use templates consistently within projects\n   - Include code and data links in papers\n   - Generate web-friendly HTML versions for sharing\n\n### Advanced Usage\n\n**Batch Link Papers:**\n```bash\n# Link multiple papers to one repository\nfor arxiv_id in \"2301.12345\" \"2302.67890\" \"2303.11111\"; do\n  uv run scripts/paper_manager.py link \\\n    --repo-id \"username/model-name\" \\\n    --repo-type \"model\" \\\n    --arxiv-id \"$arxiv_id\"\ndone\n```\n\n**Extract Paper Info:**\n```bash\n# Get paper metadata from arXiv\nuv run scripts/paper_manager.py info \\\n  --arxiv-id \"2301.12345\" \\\n  --format \"json\"\n```\n\n**Generate Citation:**\n```bash\n# Create BibTeX citation\nuv run scripts/paper_manager.py citation \\\n  --arxiv-id \"2301.12345\" \\\n  --format \"bibtex\"\n```\n\n**Validate Links:**\n```bash\n# Check all paper links in a repository\nuv run scripts/paper_manager.py validate \\\n  --repo-id \"username/model-name\" \\\n  --repo-type \"model\"\n```\n\n### Error Handling\n\n- **Paper Not Found**: arXiv ID doesn't exist or isn't indexed yet\n- **Permission Denied**: HF_TOKEN lacks write access to repository\n- **Invalid YAML**: Malformed metadata in README frontmatter\n- **Authorship Failed**: Email doesn't match paper author records\n- **Already Claimed**: Another user has claimed authorship\n- **Rate Limiting**: Too many API requests in short time\n\n### Troubleshooting\n\n**Issue**: \"Paper not found on Hugging Face\"\n- **Solution**: Visit `hf.co/papers/{arxiv-id}` to trigger indexing\n\n**Issue**: \"Authorship claim not verified\"\n- **Solution**: Wait for admin review or contact HF support with proof\n\n**Issue**: \"arXiv tag not appearing\"\n- **Solution**: Ensure README includes proper arXiv URL format\n\n**Issue**: \"Cannot link to repository\"\n- **Solution**: Verify HF_TOKEN has write permissions\n\n**Issue**: \"Template rendering errors\"\n- **Solution**: Check markdown syntax and YAML frontmatter format\n\n### Resources and References\n\n- **Hugging Face Paper Pages**: [hf.co/papers](https://huggingface.co/papers)\n- **Model Cards Guide**: [hf.co/docs/hub/model-cards](https://huggingface.co/docs/hub/en/model-cards)\n- **Dataset Cards Guide**: [hf.co/docs/hub/datasets-cards](https://huggingface.co/docs/hub/en/datasets-cards)\n- **Research Article Template**: [tfrere/research-article-template](https://huggingface.co/spaces/tfrere/research-article-template)\n- **arXiv Format Guide**: [arxiv.org/help/submit](https://arxiv.org/help/submit)\n\n### Integration with tfrere's Research Template\n\nThis skill complements [tfrere's research article template](https://huggingface.co/spaces/tfrere/research-article-template) by providing:\n\n- Automated paper indexing workflows\n- Repository linking capabilities\n- Metadata management tools\n- Citation generation utilities\n\nYou can use tfrere's template for writing, then use this skill to publish and link the paper on Hugging Face Hub.\n\n### Common Patterns\n\n**Pattern 1: New Paper Publication**\n```bash\n# Write ‚Üí Publish ‚Üí Index ‚Üí Link\nuv run scripts/paper_manager.py create --template modern --output paper.md\n# (Submit to arXiv)\nuv run scripts/paper_manager.py index --arxiv-id \"2301.12345\"\nuv run scripts/paper_manager.py link --repo-id \"user/model\" --arxiv-id \"2301.12345\"\n```\n\n**Pattern 2: Existing Paper Discovery**\n```bash\n# Search ‚Üí Check ‚Üí Link\nuv run scripts/paper_manager.py search --query \"transformers\"\nuv run scripts/paper_manager.py check --arxiv-id \"2301.12345\"\nuv run scripts/paper_manager.py link --repo-id \"user/model\" --arxiv-id \"2301.12345\"\n```\n\n**Pattern 3: Author Portfolio Management**\n```bash\n# Claim ‚Üí Verify ‚Üí Organize\nuv run scripts/paper_manager.py claim --arxiv-id \"2301.12345\"\nuv run scripts/paper_manager.py list-my-papers\nuv run scripts/paper_manager.py toggle-visibility --arxiv-id \"2301.12345\" --show true\n```\n\n### API Integration\n\n**Python Script Example:**\n```python\nfrom scripts.paper_manager import PaperManager\n\npm = PaperManager(hf_token=\"your_token\")\n\n# Index paper\npm.index_paper(\"2301.12345\")\n\n# Link to model\npm.link_paper(\n    repo_id=\"username/model\",\n    repo_type=\"model\",\n    arxiv_id=\"2301.12345\",\n    citation=\"Full citation text\"\n)\n\n# Check status\nstatus = pm.check_paper(\"2301.12345\")\nprint(status)\n```\n\n### Future Enhancements\n\nPlanned features for future versions:\n- Support for non-arXiv papers (conference proceedings, journals)\n- Automatic citation formatting from DOI\n- Paper comparison and versioning tools\n- Collaborative paper writing features\n- Integration with LaTeX workflows\n- Automated figure and table extraction\n- Paper metrics and impact tracking"
    },
    {
      "id": "huggingface-skills-hugging-face-tool-builder",
      "name": "hugging-face-tool-builder",
      "slug": "hugging-face-tool-builder",
      "description": "Use this skill when the user wants to build tool/scripts or achieve a task where using data from the Hugging Face API would help. This is especially useful when chaining or combining API calls or the task will be repeated/automated. This Skill creates a reusable script to fetch, enrich or process data.",
      "category": "Git & Workflow",
      "platform": "HuggingFace",
      "platformIcon": "ü§ó",
      "source": "huggingface/skills",
      "sourceUrl": "https://github.com/huggingface/skills/tree/main/skills/hugging-face-tool-builder",
      "skillMdUrl": "https://raw.githubusercontent.com/huggingface/skills/main/skills/hugging-face-tool-builder/SKILL.md",
      "body": "# Hugging Face API Tool Builder\n\nYour purpose is now is to create reusable command line scripts and utilities for using the Hugging Face API, allowing chaining, piping and intermediate processing where helpful. You can access the API directly, as well as use the `hf` command line tool. Model and Dataset cards can be accessed from repositories directly.\n\n## Script Rules\n\nMake sure to follow these rules:\n - Scripts must take a `--help` command line argument to describe their inputs and outputs\n - Non-destructive scripts should be tested before handing over to the User\n - Shell scripts are preferred, but use Python or TSX if complexity or user need requires it.\n - IMPORTANT: Use the `HF_TOKEN` environment variable as an Authorization header. For example: `curl -H \"Authorization: Bearer ${HF_TOKEN}\" https://huggingface.co/api/`. This provides higher rate limits and appropriate authorization for data access.\n - Investigate the shape of the API results before commiting to a final design; make use of piping and chaining where composability would be an advantage - prefer simple solutions where possible.\n - Share usage examples once complete.\n\nBe sure to confirm User preferences where there are questions or clarifications needed.\n\n## Sample Scripts\n\nPaths below are relative to this skill directory.\n\nReference examples:\n- `references/hf_model_papers_auth.sh` ‚Äî uses `HF_TOKEN` automatically and chains trending ‚Üí model metadata ‚Üí model card parsing with fallbacks; it demonstrates multi-step API usage plus auth hygiene for gated/private content.\n- `references/find_models_by_paper.sh` ‚Äî optional `HF_TOKEN` usage via `--token`, consistent authenticated search, and a retry path when arXiv-prefixed searches are too narrow; it shows resilient query strategy and clear user-facing help.\n- `references/hf_model_card_frontmatter.sh` ‚Äî uses the `hf` CLI to download model cards, extracts YAML frontmatter, and emits NDJSON summaries (license, pipeline tag, tags, gated prompt flag) for easy filtering.\n\nBaseline examples (ultra-simple, minimal logic, raw JSON output with `HF_TOKEN` header):\n- `references/baseline_hf_api.sh` ‚Äî bash\n- `references/baseline_hf_api.py` ‚Äî python\n- `references/baseline_hf_api.tsx` ‚Äî typescript executable\n\nComposable utility (stdin ‚Üí NDJSON):\n- `references/hf_enrich_models.sh` ‚Äî reads model IDs from stdin, fetches metadata per ID, emits one JSON object per line for streaming pipelines.\n\nComposability through piping (shell-friendly JSON output):\n- `references/baseline_hf_api.sh 25 | jq -r '.[].id' | references/hf_enrich_models.sh | jq -s 'sort_by(.downloads) | reverse | .[:10]'`\n- `references/baseline_hf_api.sh 50 | jq '[.[] | {id, downloads}] | sort_by(.downloads) | reverse | .[:10]'`\n- `printf '%s\\n' openai/gpt-oss-120b meta-llama/Meta-Llama-3.1-8B | references/hf_model_card_frontmatter.sh | jq -s 'map({id, license, has_extra_gated_prompt})'`\n\n## High Level Endpoints\n\nThe following are the main API endpoints available at `https://huggingface.co`\n\n```\n/api/datasets\n/api/models\n/api/spaces\n/api/collections\n/api/daily_papers\n/api/notifications\n/api/settings\n/api/whoami-v2\n/api/trending\n/oauth/userinfo\n```\n\n## Accessing the API\n\nThe API is documented with the OpenAPI standard at `https://huggingface.co/.well-known/openapi.json`.\n\n**IMPORTANT:** DO NOT ATTEMPT to read `https://huggingface.co/.well-known/openapi.json` directly as it is too large to process. \n\n**IMPORTANT** Use `jq` to query and extract relevant parts. For example, \n\n Command to Get All 160 Endpoints\n\n```bash\ncurl -s \"https://huggingface.co/.well-known/openapi.json\" | jq '.paths | keys | sort'\n```\n\nModel Search Endpoint Details\n\n```bash\ncurl -s \"https://huggingface.co/.well-known/openapi.json\" | jq '.paths[\"/api/models\"]'\n```\n\nYou can also query endpoints to see the shape of the data. When doing so constrain results to low numbers to make them easy to process, yet representative.\n\n## Using the HF command line tool\n\nThe `hf` command line tool gives you further access to Hugging Face repository content and infrastructure. \n\n```bash\n‚ùØ hf --help\nUsage: hf [OPTIONS] COMMAND [ARGS]...\n\n  Hugging Face Hub CLI\n\nOptions:\n  --help                Show this message and exit.\n\nCommands:\n  auth                 Manage authentication (login, logout, etc.).\n  cache                Manage local cache directory.\n  download             Download files from the Hub.\n  endpoints            Manage Hugging Face Inference Endpoints.\n  env                  Print information about the environment.\n  jobs                 Run and manage Jobs on the Hub.\n  repo                 Manage repos on the Hub.\n  repo-files           Manage files in a repo on the Hub.\n  upload               Upload a file or a folder to the Hub.\n  upload-large-folder  Upload a large folder to the Hub.\n  version              Print information about the hf version.\n```\n\nThe `hf` CLI command has replaced the now deprecated `huggingface_hub` CLI command."
    },
    {
      "id": "huggingface-skills-hugging-face-trackio",
      "name": "hugging-face-trackio",
      "slug": "hugging-face-trackio",
      "description": "Track and visualize ML training experiments with Trackio. Use when logging metrics during training (Python API) or retrieving/analyzing logged metrics (CLI). Supports real-time dashboard visualization, HF Space syncing, and JSON output for automation.",
      "category": "DevOps",
      "platform": "HuggingFace",
      "platformIcon": "ü§ó",
      "source": "huggingface/skills",
      "sourceUrl": "https://github.com/huggingface/skills/tree/main/skills/hugging-face-trackio",
      "skillMdUrl": "https://raw.githubusercontent.com/huggingface/skills/main/skills/hugging-face-trackio/SKILL.md",
      "body": "# Trackio - Experiment Tracking for ML Training\n\nTrackio is an experiment tracking library for logging and visualizing ML training metrics. It syncs to Hugging Face Spaces for real-time monitoring dashboards.\n\n## Two Interfaces\n\n| Task | Interface | Reference |\n|------|-----------|-----------|\n| **Logging metrics** during training | Python API | [references/logging_metrics.md](references/logging_metrics.md) |\n| **Retrieving metrics** after/during training | CLI | [references/retrieving_metrics.md](references/retrieving_metrics.md) |\n\n## When to Use Each\n\n### Python API ‚Üí Logging\n\nUse `import trackio` in your training scripts to log metrics:\n\n- Initialize tracking with `trackio.init()`\n- Log metrics with `trackio.log()` or use TRL's `report_to=\"trackio\"`\n- Finalize with `trackio.finish()`\n\n**Key concept**: For remote/cloud training, pass `space_id` ‚Äî metrics sync to a Space dashboard so they persist after the instance terminates.\n\n‚Üí See [references/logging_metrics.md](references/logging_metrics.md) for setup, TRL integration, and configuration options.\n\n### CLI ‚Üí Retrieving\n\nUse the `trackio` command to query logged metrics:\n\n- `trackio list projects/runs/metrics` ‚Äî discover what's available\n- `trackio get project/run/metric` ‚Äî retrieve summaries and values\n- `trackio show` ‚Äî launch the dashboard\n- `trackio sync` ‚Äî sync to HF Space\n\n**Key concept**: Add `--json` for programmatic output suitable for automation and LLM agents.\n\n‚Üí See [references/retrieving_metrics.md](references/retrieving_metrics.md) for all commands, workflows, and JSON output formats.\n\n## Minimal Logging Setup\n\n```python\nimport trackio\n\ntrackio.init(project=\"my-project\", space_id=\"username/trackio\")\ntrackio.log({\"loss\": 0.1, \"accuracy\": 0.9})\ntrackio.log({\"loss\": 0.09, \"accuracy\": 0.91})\ntrackio.finish()\n```\n\n### Minimal Retrieval\n\n```bash\ntrackio list projects --json\ntrackio get metric --project my-project --run my-run --metric loss --json\n```"
    },
    {
      "id": "muratcankoylan-Agent-Skills-for-Context-Engineering-docs",
      "name": "PDF Processing",
      "slug": "docs",
      "description": "A simple, open format for giving agents new capabilities and expertise.",
      "category": "Git & Workflow",
      "platform": "Context Engineering",
      "platformIcon": "üß†",
      "source": "muratcankoylan/Agent-Skills-for-Context-Engineering",
      "sourceUrl": "https://github.com/muratcankoylan/Agent-Skills-for-Context-Engineering/tree/main/docs",
      "skillMdUrl": "https://raw.githubusercontent.com/muratcankoylan/Agent-Skills-for-Context-Engineering/main/docs/agentskills.md",
      "body": "---\nname: agent-skills-format\ndescription: Official documentation for the Agent Skills format - a lightweight, open standard for extending AI agent capabilities with specialized knowledge and workflows.\ndoc_type: reference\nsource_url: No\n---\n\nOverview\n\nCopy page\n\nA simple, open format for giving agents new capabilities and expertise.\n\nAgent Skills are folders of instructions, scripts, and resources that agents can discover and use to do things more accurately and efficiently.\n‚Äã\nWhy Agent Skills?\nAgents are increasingly capable, but often don‚Äôt have the context they need to do real work reliably. Skills solve this by giving agents access to procedural knowledge and company-, team-, and user-specific context they can load on demand. Agents with access to a set of skills can extend their capabilities based on the task they‚Äôre working on.\nFor skill authors: Build capabilities once and deploy them across multiple agent products.\nFor compatible agents: Support for skills lets end users give agents new capabilities out of the box.\nFor teams and enterprises: Capture organizational knowledge in portable, version-controlled packages.\n‚Äã\nWhat can Agent Skills enable?\nDomain expertise: Package specialized knowledge into reusable instructions, from legal review processes to data analysis pipelines.\nNew capabilities: Give agents new capabilities (e.g. creating presentations, building MCP servers, analyzing datasets).\nRepeatable workflows: Turn multi-step tasks into consistent and auditable workflows.\nInteroperability: Reuse the same skill across different skills-compatible agent products.\n‚Äã\nAdoption\nAgent Skills are supported by leading AI development tools.\nOpenCode\nCursor\nAmp\nLetta\nGoose\nGitHub\nVS Code\nClaude Code\nClaude\nOpenAI Codex\n‚Äã\nOpen development\nThe Agent Skills format was originally developed by Anthropic, released as an open standard, and has been adopted by a growing number of agent products. The standard is open to contributions from the broader ecosystem.\n\nWhat are s"
    },
    {
      "id": "obra-superpowers-receiving-code-review",
      "name": "receiving-code-review",
      "slug": "receiving-code-review",
      "description": "Use when receiving code review feedback, before implementing suggestions, especially if feedback seems unclear or technically questionable - requires technical rigor and verification, not performative agreement or blind implementation",
      "category": "Quality",
      "platform": "Superpowers",
      "platformIcon": "‚ö°",
      "source": "obra/superpowers",
      "sourceUrl": "https://github.com/obra/superpowers/tree/main/skills/receiving-code-review",
      "skillMdUrl": "https://raw.githubusercontent.com/obra/superpowers/main/skills/receiving-code-review/SKILL.md",
      "body": "# Code Review Reception\n\n## Overview\n\nCode review requires technical evaluation, not emotional performance.\n\n**Core principle:** Verify before implementing. Ask before assuming. Technical correctness over social comfort.\n\n## The Response Pattern\n\n```\nWHEN receiving code review feedback:\n\n1. READ: Complete feedback without reacting\n2. UNDERSTAND: Restate requirement in own words (or ask)\n3. VERIFY: Check against codebase reality\n4. EVALUATE: Technically sound for THIS codebase?\n5. RESPOND: Technical acknowledgment or reasoned pushback\n6. IMPLEMENT: One item at a time, test each\n```\n\n## Forbidden Responses\n\n**NEVER:**\n- \"You're absolutely right!\" (explicit CLAUDE.md violation)\n- \"Great point!\" / \"Excellent feedback!\" (performative)\n- \"Let me implement that now\" (before verification)\n\n**INSTEAD:**\n- Restate the technical requirement\n- Ask clarifying questions\n- Push back with technical reasoning if wrong\n- Just start working (actions > words)\n\n## Handling Unclear Feedback\n\n```\nIF any item is unclear:\n  STOP - do not implement anything yet\n  ASK for clarification on unclear items\n\nWHY: Items may be related. Partial understanding = wrong implementation.\n```\n\n**Example:**\n```\nyour human partner: \"Fix 1-6\"\nYou understand 1,2,3,6. Unclear on 4,5.\n\n‚ùå WRONG: Implement 1,2,3,6 now, ask about 4,5 later\n‚úÖ RIGHT: \"I understand items 1,2,3,6. Need clarification on 4 and 5 before proceeding.\"\n```\n\n## Source-Specific Handling\n\n### From your human partner\n- **Trusted** - implement after understanding\n- **Still ask** if scope unclear\n- **No performative agreement**\n- **Skip to action** or technical acknowledgment\n\n### From External Reviewers\n```\nBEFORE implementing:\n  1. Check: Technically correct for THIS codebase?\n  2. Check: Breaks existing functionality?\n  3. Check: Reason for current implementation?\n  4. Check: Works on all platforms/versions?\n  5. Check: Does reviewer understand full context?\n\nIF suggestion seems wrong:\n  Push back with technical reasoning\n\nIF can't easily verify:\n  Say so: \"I can't verify this without [X]. Should I [investigate/ask/proceed]?\"\n\nIF conflicts with your human partner's prior decisions:\n  Stop and discuss with your human partner first\n```\n\n**your human partner's rule:** \"External feedback - be skeptical, but check carefully\"\n\n## YAGNI Check for \"Professional\" Features\n\n```\nIF reviewer suggests \"implementing properly\":\n  grep codebase for actual usage\n\n  IF unused: \"This endpoint isn't called. Remove it (YAGNI)?\"\n  IF used: Then implement properly\n```\n\n**your human partner's rule:** \"You and reviewer both report to me. If we don't need this feature, don't add it.\"\n\n## Implementation Order\n\n```\nFOR multi-item feedback:\n  1. Clarify anything unclear FIRST\n  2. Then implement in this order:\n     - Blocking issues (breaks, security)\n     - Simple fixes (typos, imports)\n     - Complex fixes (refactoring, logic)\n  3. Test each fix individually\n  4. Verify no regressions\n```\n\n## When To Push Back\n\nPush back when:\n- Suggestion breaks existing functionality\n- Reviewer lacks full context\n- Violates YAGNI (unused feature)\n- Technically incorrect for this stack\n- Legacy/compatibility reasons exist\n- Conflicts with your human partner's architectural decisions\n\n**How to push back:**\n- Use technical reasoning, not defensiveness\n- Ask specific questions\n- Reference working tests/code\n- Involve your human partner if architectural\n\n**Signal if uncomfortable pushing back out loud:** \"Strange things are afoot at the Circle K\"\n\n## Acknowledging Correct Feedback\n\nWhen feedback IS correct:\n```\n‚úÖ \"Fixed. [Brief description of what changed]\"\n‚úÖ \"Good catch - [specific issue]. Fixed in [location].\"\n‚úÖ [Just fix it and show in the code]\n\n‚ùå \"You're absolutely right!\"\n‚ùå \"Great point!\"\n‚ùå \"Thanks for catching that!\"\n‚ùå \"Thanks for [anything]\"\n‚ùå ANY gratitude expression\n```\n\n**Why no thanks:** Actions speak. Just fix it. The code itself shows you heard the feedback.\n\n**If you catch yourself about to write \"Thanks\":** DELETE IT. State the fix instead.\n\n## Gracefully Correcting Your Pushback\n\nIf you pushed back and were wrong:\n```\n‚úÖ \"You were right - I checked [X] and it does [Y]. Implementing now.\"\n‚úÖ \"Verified this and you're correct. My initial understanding was wrong because [reason]. Fixing.\"\n\n‚ùå Long apology\n‚ùå Defending why you pushed back\n‚ùå Over-explaining\n```\n\nState the correction factually and move on.\n\n## Common Mistakes\n\n| Mistake | Fix |\n|---------|-----|\n| Performative agreement | State requirement or just act |\n| Blind implementation | Verify against codebase first |\n| Batch without testing | One at a time, test each |\n| Assuming reviewer is right | Check if breaks things |\n| Avoiding pushback | Technical correctness > comfort |\n| Partial implementation | Clarify all items first |\n| Can't verify, proceed anyway | State limitation, ask for direction |\n\n## Real Examples\n\n**Performative Agreement (Bad):**\n```\nReviewer: \"Remove legacy code\"\n‚ùå \"You're absolutely right! Let me remove that...\"\n```\n\n**Technical Verification (Good):**\n```\nReviewer: \"Remove legacy code\"\n‚úÖ \"Checking... build target is 10.15+, this API needs 13+. Need legacy for backward compat. Current impl has wrong bundle ID - fix it or drop pre-13 support?\"\n```\n\n**YAGNI (Good):**\n```\nReviewer: \"Implement proper metrics tracking with database, date filters, CSV export\"\n‚úÖ \"Grepped codebase - nothing calls this endpoint. Remove it (YAGNI)? Or is there usage I'm missing?\"\n```\n\n**Unclear Item (Good):**\n```\nyour human partner: \"Fix items 1-6\"\nYou understand 1,2,3,6. Unclear on 4,5.\n‚úÖ \"Understand 1,2,3,6. Need clarification on 4 and 5 before implementing.\"\n```\n\n## GitHub Thread Replies\n\nWhen replying to inline review comments on GitHub, reply in the comment thread (`gh api repos/{owner}/{repo}/pulls/{pr}/comments/{id}/replies`), not as a top-level PR comment.\n\n## The Bottom Line\n\n**External feedback = suggestions to evaluate, not orders to follow.**\n\nVerify. Question. Then implement.\n\nNo performative agreement. Technical rigor always."
    },
    {
      "id": "obra-superpowers-requesting-code-review",
      "name": "requesting-code-review",
      "slug": "requesting-code-review",
      "description": "Use when completing tasks, implementing major features, or before merging to verify work meets requirements",
      "category": "Quality",
      "platform": "Superpowers",
      "platformIcon": "‚ö°",
      "source": "obra/superpowers",
      "sourceUrl": "https://github.com/obra/superpowers/tree/main/skills/requesting-code-review",
      "skillMdUrl": "https://raw.githubusercontent.com/obra/superpowers/main/skills/requesting-code-review/SKILL.md",
      "body": "# Requesting Code Review\n\nDispatch superpowers:code-reviewer subagent to catch issues before they cascade.\n\n**Core principle:** Review early, review often.\n\n## When to Request Review\n\n**Mandatory:**\n- After each task in subagent-driven development\n- After completing major feature\n- Before merge to main\n\n**Optional but valuable:**\n- When stuck (fresh perspective)\n- Before refactoring (baseline check)\n- After fixing complex bug\n\n## How to Request\n\n**1. Get git SHAs:**\n```bash\nBASE_SHA=$(git rev-parse HEAD~1)  # or origin/main\nHEAD_SHA=$(git rev-parse HEAD)\n```\n\n**2. Dispatch code-reviewer subagent:**\n\nUse Task tool with superpowers:code-reviewer type, fill template at `code-reviewer.md`\n\n**Placeholders:**\n- `{WHAT_WAS_IMPLEMENTED}` - What you just built\n- `{PLAN_OR_REQUIREMENTS}` - What it should do\n- `{BASE_SHA}` - Starting commit\n- `{HEAD_SHA}` - Ending commit\n- `{DESCRIPTION}` - Brief summary\n\n**3. Act on feedback:**\n- Fix Critical issues immediately\n- Fix Important issues before proceeding\n- Note Minor issues for later\n- Push back if reviewer is wrong (with reasoning)\n\n## Example\n\n```\n[Just completed Task 2: Add verification function]\n\nYou: Let me request code review before proceeding.\n\nBASE_SHA=$(git log --oneline | grep \"Task 1\" | head -1 | awk '{print $1}')\nHEAD_SHA=$(git rev-parse HEAD)\n\n[Dispatch superpowers:code-reviewer subagent]\n  WHAT_WAS_IMPLEMENTED: Verification and repair functions for conversation index\n  PLAN_OR_REQUIREMENTS: Task 2 from docs/plans/deployment-plan.md\n  BASE_SHA: a7981ec\n  HEAD_SHA: 3df7661\n  DESCRIPTION: Added verifyIndex() and repairIndex() with 4 issue types\n\n[Subagent returns]:\n  Strengths: Clean architecture, real tests\n  Issues:\n    Important: Missing progress indicators\n    Minor: Magic number (100) for reporting interval\n  Assessment: Ready to proceed\n\nYou: [Fix progress indicators]\n[Continue to Task 3]\n```\n\n## Integration with Workflows\n\n**Subagent-Driven Development:**\n- Review after EACH task\n- Catch issues before they compound\n- Fix before moving to next task\n\n**Executing Plans:**\n- Review after each batch (3 tasks)\n- Get feedback, apply, continue\n\n**Ad-Hoc Development:**\n- Review before merge\n- Review when stuck\n\n## Red Flags\n\n**Never:**\n- Skip review because \"it's simple\"\n- Ignore Critical issues\n- Proceed with unfixed Important issues\n- Argue with valid technical feedback\n\n**If reviewer wrong:**\n- Push back with technical reasoning\n- Show code/tests that prove it works\n- Request clarification\n\nSee template at: requesting-code-review/code-reviewer.md"
    },
    {
      "id": "muratcankoylan-Agent-Skills-for-Context-Engineering-template",
      "name": "Skill Name",
      "slug": "template",
      "description": "Provide a clear, concise description of what this skill covers and when to use it. This description appears in skill discovery and should help agents (and humans) determine when this skill is relevant",
      "category": "General",
      "platform": "Context Engineering",
      "platformIcon": "üß†",
      "source": "muratcankoylan/Agent-Skills-for-Context-Engineering",
      "sourceUrl": "https://github.com/muratcankoylan/Agent-Skills-for-Context-Engineering/tree/main/template",
      "skillMdUrl": "https://raw.githubusercontent.com/muratcankoylan/Agent-Skills-for-Context-Engineering/main/template/SKILL.md",
      "body": "---\nname: skill-template\ndescription: Template for creating new Agent Skills for context engineering. Use this template when adding new skills to the collection.\n---\n\n# Skill Name\n\nProvide a clear, concise description of what this skill covers and when to use it. This description appears in skill discovery and should help agents (and humans) determine when this skill is relevant.\n\n**Important**: Keep the total SKILL.md body under 500 lines for optimal performance. Move detailed reference material to separate files in the `references/` directory.\n\n## When to Activate\n\nDescribe specific situations, tasks, or contexts where this skill should be activated. Include both direct triggers (specific keywords or task types) and indirect signals (broader patterns that indicate skill relevance).\n\nWrite in third person. The description is injected into the system prompt, and inconsistent point-of-view can cause discovery problems.\n\n- Good: \"Processes Excel files and generates reports\"\n- Avoid: \"I can help you process Excel files\"\n\n## Core Concepts\n\nExplain the fundamental concepts covered by this skill. These are the mental models, principles, or frameworks that the skill teaches.\n\nDefault assumption: Claude is already very smart. Only add context Claude does not already have. Challenge each piece of information:\n- \"Does Claude really need this explanation?\"\n- \"Can I assume Claude knows this?\"\n- \"Does this paragraph justify its token cost?\"\n\n## Detailed Topics\n\n### Topic 1\n\nProvide detailed explanation of the first major topic. Include specific techniques, patterns, or approaches. Use examples to illustrate concepts.\n\n### Topic 2\n\nProvide detailed explanation of the second major topic. Continue with additional topics as needed.\n\nFor longer topics, consider moving content to `references/` and linking:\n- See [detailed reference](./references/topic-details.md) for complete implementation\n\n## Practical Guidance\n\nProvide actionable guidance for applying the skill. Include common patt"
    },
    {
      "id": "obra-superpowers-subagent-driven-development",
      "name": "subagent-driven-development",
      "slug": "subagent-driven-development",
      "description": "Use when executing implementation plans with independent tasks in the current session",
      "category": "Planning",
      "platform": "Superpowers",
      "platformIcon": "‚ö°",
      "source": "obra/superpowers",
      "sourceUrl": "https://github.com/obra/superpowers/tree/main/skills/subagent-driven-development",
      "skillMdUrl": "https://raw.githubusercontent.com/obra/superpowers/main/skills/subagent-driven-development/SKILL.md",
      "body": "# Subagent-Driven Development\n\nExecute plan by dispatching fresh subagent per task, with two-stage review after each: spec compliance review first, then code quality review.\n\n**Core principle:** Fresh subagent per task + two-stage review (spec then quality) = high quality, fast iteration\n\n## When to Use\n\n```dot\ndigraph when_to_use {\n    \"Have implementation plan?\" [shape=diamond];\n    \"Tasks mostly independent?\" [shape=diamond];\n    \"Stay in this session?\" [shape=diamond];\n    \"subagent-driven-development\" [shape=box];\n    \"executing-plans\" [shape=box];\n    \"Manual execution or brainstorm first\" [shape=box];\n\n    \"Have implementation plan?\" -> \"Tasks mostly independent?\" [label=\"yes\"];\n    \"Have implementation plan?\" -> \"Manual execution or brainstorm first\" [label=\"no\"];\n    \"Tasks mostly independent?\" -> \"Stay in this session?\" [label=\"yes\"];\n    \"Tasks mostly independent?\" -> \"Manual execution or brainstorm first\" [label=\"no - tightly coupled\"];\n    \"Stay in this session?\" -> \"subagent-driven-development\" [label=\"yes\"];\n    \"Stay in this session?\" -> \"executing-plans\" [label=\"no - parallel session\"];\n}\n```\n\n**vs. Executing Plans (parallel session):**\n- Same session (no context switch)\n- Fresh subagent per task (no context pollution)\n- Two-stage review after each task: spec compliance first, then code quality\n- Faster iteration (no human-in-loop between tasks)\n\n## The Process\n\n```dot\ndigraph process {\n    rankdir=TB;\n\n    subgraph cluster_per_task {\n        label=\"Per Task\";\n        \"Dispatch implementer subagent (./implementer-prompt.md)\" [shape=box];\n        \"Implementer subagent asks questions?\" [shape=diamond];\n        \"Answer questions, provide context\" [shape=box];\n        \"Implementer subagent implements, tests, commits, self-reviews\" [shape=box];\n        \"Dispatch spec reviewer subagent (./spec-reviewer-prompt.md)\" [shape=box];\n        \"Spec reviewer subagent confirms code matches spec?\" [shape=diamond];\n        \"Implementer subagent fixes spec gaps\" [shape=box];\n        \"Dispatch code quality reviewer subagent (./code-quality-reviewer-prompt.md)\" [shape=box];\n        \"Code quality reviewer subagent approves?\" [shape=diamond];\n        \"Implementer subagent fixes quality issues\" [shape=box];\n        \"Mark task complete in TodoWrite\" [shape=box];\n    }\n\n    \"Read plan, extract all tasks with full text, note context, create TodoWrite\" [shape=box];\n    \"More tasks remain?\" [shape=diamond];\n    \"Dispatch final code reviewer subagent for entire implementation\" [shape=box];\n    \"Use superpowers:finishing-a-development-branch\" [shape=box style=filled fillcolor=lightgreen];\n\n    \"Read plan, extract all tasks with full text, note context, create TodoWrite\" -> \"Dispatch implementer subagent (./implementer-prompt.md)\";\n    \"Dispatch implementer subagent (./implementer-prompt.md)\" -> \"Implementer subagent asks questions?\";\n    \"Implementer subagent asks questions?\" -> \"Answer questions, provide context\" [label=\"yes\"];\n    \"Answer questions, provide context\" -> \"Dispatch implementer subagent (./implementer-prompt.md)\";\n    \"Implementer subagent asks questions?\" -> \"Implementer subagent implements, tests, commits, self-reviews\" [label=\"no\"];\n    \"Implementer subagent implements, tests, commits, self-reviews\" -> \"Dispatch spec reviewer subagent (./spec-reviewer-prompt.md)\";\n    \"Dispatch spec reviewer subagent (./spec-reviewer-prompt.md)\" -> \"Spec reviewer subagent confirms code matches spec?\";\n    \"Spec reviewer subagent confirms code matches spec?\" -> \"Implementer subagent fixes spec gaps\" [label=\"no\"];\n    \"Implementer subagent fixes spec gaps\" -> \"Dispatch spec reviewer subagent (./spec-reviewer-prompt.md)\" [label=\"re-review\"];\n    \"Spec reviewer subagent confirms code matches spec?\" -> \"Dispatch code quality reviewer subagent (./code-quality-reviewer-prompt.md)\" [label=\"yes\"];\n    \"Dispatch code quality reviewer subagent (./code-quality-reviewer-prompt.md)\" -> \"Code quality reviewer subagent approves?\";\n    \"Code quality reviewer subagent approves?\" -> \"Implementer subagent fixes quality issues\" [label=\"no\"];\n    \"Implementer subagent fixes quality issues\" -> \"Dispatch code quality reviewer subagent (./code-quality-reviewer-prompt.md)\" [label=\"re-review\"];\n    \"Code quality reviewer subagent approves?\" -> \"Mark task complete in TodoWrite\" [label=\"yes\"];\n    \"Mark task complete in TodoWrite\" -> \"More tasks remain?\";\n    \"More tasks remain?\" -> \"Dispatch implementer subagent (./implementer-prompt.md)\" [label=\"yes\"];\n    \"More tasks remain?\" -> \"Dispatch final code reviewer subagent for entire implementation\" [label=\"no\"];\n    \"Dispatch final code reviewer subagent for entire implementation\" -> \"Use superpowers:finishing-a-development-branch\";\n}\n```\n\n## Prompt Templates\n\n- `./implementer-prompt.md` - Dispatch implementer subagent\n- `./spec-reviewer-prompt.md` - Dispatch spec compliance reviewer subagent\n- `./code-quality-reviewer-prompt.md` - Dispatch code quality reviewer subagent\n\n## Example Workflow\n\n```\nYou: I'm using Subagent-Driven Development to execute this plan.\n\n[Read plan file once: docs/plans/feature-plan.md]\n[Extract all 5 tasks with full text and context]\n[Create TodoWrite with all tasks]\n\nTask 1: Hook installation script\n\n[Get Task 1 text and context (already extracted)]\n[Dispatch implementation subagent with full task text + context]\n\nImplementer: \"Before I begin - should the hook be installed at user or system level?\"\n\nYou: \"User level (~/.config/superpowers/hooks/)\"\n\nImplementer: \"Got it. Implementing now...\"\n[Later] Implementer:\n  - Implemented install-hook command\n  - Added tests, 5/5 passing\n  - Self-review: Found I missed --force flag, added it\n  - Committed\n\n[Dispatch spec compliance reviewer]\nSpec reviewer: ‚úÖ Spec compliant - all requirements met, nothing extra\n\n[Get git SHAs, dispatch code quality reviewer]\nCode reviewer: Strengths: Good test coverage, clean. Issues: None. Approved.\n\n[Mark Task 1 complete]\n\nTask 2: Recovery modes\n\n[Get Task 2 text and context (already extracted)]\n[Dispatch implementation subagent with full task text + context]\n\nImplementer: [No questions, proceeds]\nImplementer:\n  - Added verify/repair modes\n  - 8/8 tests passing\n  - Self-review: All good\n  - Committed\n\n[Dispatch spec compliance reviewer]\nSpec reviewer: ‚ùå Issues:\n  - Missing: Progress reporting (spec says \"report every 100 items\")\n  - Extra: Added --json flag (not requested)\n\n[Implementer fixes issues]\nImplementer: Removed --json flag, added progress reporting\n\n[Spec reviewer reviews again]\nSpec reviewer: ‚úÖ Spec compliant now\n\n[Dispatch code quality reviewer]\nCode reviewer: Strengths: Solid. Issues (Important): Magic number (100)\n\n[Implementer fixes]\nImplementer: Extracted PROGRESS_INTERVAL constant\n\n[Code reviewer reviews again]\nCode reviewer: ‚úÖ Approved\n\n[Mark Task 2 complete]\n\n...\n\n[After all tasks]\n[Dispatch final code-reviewer]\nFinal reviewer: All requirements met, ready to merge\n\nDone!\n```\n\n## Advantages\n\n**vs. Manual execution:**\n- Subagents follow TDD naturally\n- Fresh context per task (no confusion)\n- Parallel-safe (subagents don't interfere)\n- Subagent can ask questions (before AND during work)\n\n**vs. Executing Plans:**\n- Same session (no handoff)\n- Continuous progress (no waiting)\n- Review checkpoints automatic\n\n**Efficiency gains:**\n- No file reading overhead (controller provides full text)\n- Controller curates exactly what context is needed\n- Subagent gets complete information upfront\n- Questions surfaced before work begins (not after)\n\n**Quality gates:**\n- Self-review catches issues before handoff\n- Two-stage review: spec compliance, then code quality\n- Review loops ensure fixes actually work\n- Spec compliance prevents over/under-building\n- Code quality ensures implementation is well-built\n\n**Cost:**\n- More subagent invocations (implementer + 2 reviewers per task)\n- Controller does more prep work (extracting all tasks upfront)\n- Review loops add iterations\n- But catches issues early (cheaper than debugging later)\n\n## Red Flags\n\n**Never:**\n- Start implementation on main/master branch without explicit user consent\n- Skip reviews (spec compliance OR code quality)\n- Proceed with unfixed issues\n- Dispatch multiple implementation subagents in parallel (conflicts)\n- Make subagent read plan file (provide full text instead)\n- Skip scene-setting context (subagent needs to understand where task fits)\n- Ignore subagent questions (answer before letting them proceed)\n- Accept \"close enough\" on spec compliance (spec reviewer found issues = not done)\n- Skip review loops (reviewer found issues = implementer fixes = review again)\n- Let implementer self-review replace actual review (both are needed)\n- **Start code quality review before spec compliance is ‚úÖ** (wrong order)\n- Move to next task while either review has open issues\n\n**If subagent asks questions:**\n- Answer clearly and completely\n- Provide additional context if needed\n- Don't rush them into implementation\n\n**If reviewer finds issues:**\n- Implementer (same subagent) fixes them\n- Reviewer reviews again\n- Repeat until approved\n- Don't skip the re-review\n\n**If subagent fails task:**\n- Dispatch fix subagent with specific instructions\n- Don't try to fix manually (context pollution)\n\n## Integration\n\n**Required workflow skills:**\n- **superpowers:using-git-worktrees** - REQUIRED: Set up isolated workspace before starting\n- **superpowers:writing-plans** - Creates the plan this skill executes\n- **superpowers:requesting-code-review** - Code review template for reviewer subagents\n- **superpowers:finishing-a-development-branch** - Complete development after all tasks\n\n**Subagents should use:**\n- **superpowers:test-driven-development** - Subagents follow TDD for each task\n\n**Alternative workflow:**\n- **superpowers:executing-plans** - Use for parallel session instead of same-session execution"
    },
    {
      "id": "obra-superpowers-systematic-debugging",
      "name": "systematic-debugging",
      "slug": "systematic-debugging",
      "description": "Use when encountering any bug, test failure, or unexpected behavior, before proposing fixes",
      "category": "Quality",
      "platform": "Superpowers",
      "platformIcon": "‚ö°",
      "source": "obra/superpowers",
      "sourceUrl": "https://github.com/obra/superpowers/tree/main/skills/systematic-debugging",
      "skillMdUrl": "https://raw.githubusercontent.com/obra/superpowers/main/skills/systematic-debugging/SKILL.md",
      "body": "# Systematic Debugging\n\n## Overview\n\nRandom fixes waste time and create new bugs. Quick patches mask underlying issues.\n\n**Core principle:** ALWAYS find root cause before attempting fixes. Symptom fixes are failure.\n\n**Violating the letter of this process is violating the spirit of debugging.**\n\n## The Iron Law\n\n```\nNO FIXES WITHOUT ROOT CAUSE INVESTIGATION FIRST\n```\n\nIf you haven't completed Phase 1, you cannot propose fixes.\n\n## When to Use\n\nUse for ANY technical issue:\n- Test failures\n- Bugs in production\n- Unexpected behavior\n- Performance problems\n- Build failures\n- Integration issues\n\n**Use this ESPECIALLY when:**\n- Under time pressure (emergencies make guessing tempting)\n- \"Just one quick fix\" seems obvious\n- You've already tried multiple fixes\n- Previous fix didn't work\n- You don't fully understand the issue\n\n**Don't skip when:**\n- Issue seems simple (simple bugs have root causes too)\n- You're in a hurry (rushing guarantees rework)\n- Manager wants it fixed NOW (systematic is faster than thrashing)\n\n## The Four Phases\n\nYou MUST complete each phase before proceeding to the next.\n\n### Phase 1: Root Cause Investigation\n\n**BEFORE attempting ANY fix:**\n\n1. **Read Error Messages Carefully**\n   - Don't skip past errors or warnings\n   - They often contain the exact solution\n   - Read stack traces completely\n   - Note line numbers, file paths, error codes\n\n2. **Reproduce Consistently**\n   - Can you trigger it reliably?\n   - What are the exact steps?\n   - Does it happen every time?\n   - If not reproducible ‚Üí gather more data, don't guess\n\n3. **Check Recent Changes**\n   - What changed that could cause this?\n   - Git diff, recent commits\n   - New dependencies, config changes\n   - Environmental differences\n\n4. **Gather Evidence in Multi-Component Systems**\n\n   **WHEN system has multiple components (CI ‚Üí build ‚Üí signing, API ‚Üí service ‚Üí database):**\n\n   **BEFORE proposing fixes, add diagnostic instrumentation:**\n   ```\n   For EACH component boundary:\n     - Log what data enters component\n     - Log what data exits component\n     - Verify environment/config propagation\n     - Check state at each layer\n\n   Run once to gather evidence showing WHERE it breaks\n   THEN analyze evidence to identify failing component\n   THEN investigate that specific component\n   ```\n\n   **Example (multi-layer system):**\n   ```bash\n   # Layer 1: Workflow\n   echo \"=== Secrets available in workflow: ===\"\n   echo \"IDENTITY: ${IDENTITY:+SET}${IDENTITY:-UNSET}\"\n\n   # Layer 2: Build script\n   echo \"=== Env vars in build script: ===\"\n   env | grep IDENTITY || echo \"IDENTITY not in environment\"\n\n   # Layer 3: Signing script\n   echo \"=== Keychain state: ===\"\n   security list-keychains\n   security find-identity -v\n\n   # Layer 4: Actual signing\n   codesign --sign \"$IDENTITY\" --verbose=4 \"$APP\"\n   ```\n\n   **This reveals:** Which layer fails (secrets ‚Üí workflow ‚úì, workflow ‚Üí build ‚úó)\n\n5. **Trace Data Flow**\n\n   **WHEN error is deep in call stack:**\n\n   See `root-cause-tracing.md` in this directory for the complete backward tracing technique.\n\n   **Quick version:**\n   - Where does bad value originate?\n   - What called this with bad value?\n   - Keep tracing up until you find the source\n   - Fix at source, not at symptom\n\n### Phase 2: Pattern Analysis\n\n**Find the pattern before fixing:**\n\n1. **Find Working Examples**\n   - Locate similar working code in same codebase\n   - What works that's similar to what's broken?\n\n2. **Compare Against References**\n   - If implementing pattern, read reference implementation COMPLETELY\n   - Don't skim - read every line\n   - Understand the pattern fully before applying\n\n3. **Identify Differences**\n   - What's different between working and broken?\n   - List every difference, however small\n   - Don't assume \"that can't matter\"\n\n4. **Understand Dependencies**\n   - What other components does this need?\n   - What settings, config, environment?\n   - What assumptions does it make?\n\n### Phase 3: Hypothesis and Testing\n\n**Scientific method:**\n\n1. **Form Single Hypothesis**\n   - State clearly: \"I think X is the root cause because Y\"\n   - Write it down\n   - Be specific, not vague\n\n2. **Test Minimally**\n   - Make the SMALLEST possible change to test hypothesis\n   - One variable at a time\n   - Don't fix multiple things at once\n\n3. **Verify Before Continuing**\n   - Did it work? Yes ‚Üí Phase 4\n   - Didn't work? Form NEW hypothesis\n   - DON'T add more fixes on top\n\n4. **When You Don't Know**\n   - Say \"I don't understand X\"\n   - Don't pretend to know\n   - Ask for help\n   - Research more\n\n### Phase 4: Implementation\n\n**Fix the root cause, not the symptom:**\n\n1. **Create Failing Test Case**\n   - Simplest possible reproduction\n   - Automated test if possible\n   - One-off test script if no framework\n   - MUST have before fixing\n   - Use the `superpowers:test-driven-development` skill for writing proper failing tests\n\n2. **Implement Single Fix**\n   - Address the root cause identified\n   - ONE change at a time\n   - No \"while I'm here\" improvements\n   - No bundled refactoring\n\n3. **Verify Fix**\n   - Test passes now?\n   - No other tests broken?\n   - Issue actually resolved?\n\n4. **If Fix Doesn't Work**\n   - STOP\n   - Count: How many fixes have you tried?\n   - If < 3: Return to Phase 1, re-analyze with new information\n   - **If ‚â• 3: STOP and question the architecture (step 5 below)**\n   - DON'T attempt Fix #4 without architectural discussion\n\n5. **If 3+ Fixes Failed: Question Architecture**\n\n   **Pattern indicating architectural problem:**\n   - Each fix reveals new shared state/coupling/problem in different place\n   - Fixes require \"massive refactoring\" to implement\n   - Each fix creates new symptoms elsewhere\n\n   **STOP and question fundamentals:**\n   - Is this pattern fundamentally sound?\n   - Are we \"sticking with it through sheer inertia\"?\n   - Should we refactor architecture vs. continue fixing symptoms?\n\n   **Discuss with your human partner before attempting more fixes**\n\n   This is NOT a failed hypothesis - this is a wrong architecture.\n\n## Red Flags - STOP and Follow Process\n\nIf you catch yourself thinking:\n- \"Quick fix for now, investigate later\"\n- \"Just try changing X and see if it works\"\n- \"Add multiple changes, run tests\"\n- \"Skip the test, I'll manually verify\"\n- \"It's probably X, let me fix that\"\n- \"I don't fully understand but this might work\"\n- \"Pattern says X but I'll adapt it differently\"\n- \"Here are the main problems: [lists fixes without investigation]\"\n- Proposing solutions before tracing data flow\n- **\"One more fix attempt\" (when already tried 2+)**\n- **Each fix reveals new problem in different place**\n\n**ALL of these mean: STOP. Return to Phase 1.**\n\n**If 3+ fixes failed:** Question the architecture (see Phase 4.5)\n\n## your human partner's Signals You're Doing It Wrong\n\n**Watch for these redirections:**\n- \"Is that not happening?\" - You assumed without verifying\n- \"Will it show us...?\" - You should have added evidence gathering\n- \"Stop guessing\" - You're proposing fixes without understanding\n- \"Ultrathink this\" - Question fundamentals, not just symptoms\n- \"We're stuck?\" (frustrated) - Your approach isn't working\n\n**When you see these:** STOP. Return to Phase 1.\n\n## Common Rationalizations\n\n| Excuse | Reality |\n|--------|---------|\n| \"Issue is simple, don't need process\" | Simple issues have root causes too. Process is fast for simple bugs. |\n| \"Emergency, no time for process\" | Systematic debugging is FASTER than guess-and-check thrashing. |\n| \"Just try this first, then investigate\" | First fix sets the pattern. Do it right from the start. |\n| \"I'll write test after confirming fix works\" | Untested fixes don't stick. Test first proves it. |\n| \"Multiple fixes at once saves time\" | Can't isolate what worked. Causes new bugs. |\n| \"Reference too long, I'll adapt the pattern\" | Partial understanding guarantees bugs. Read it completely. |\n| \"I see the problem, let me fix it\" | Seeing symptoms ‚â† understanding root cause. |\n| \"One more fix attempt\" (after 2+ failures) | 3+ failures = architectural problem. Question pattern, don't fix again. |\n\n## Quick Reference\n\n| Phase | Key Activities | Success Criteria |\n|-------|---------------|------------------|\n| **1. Root Cause** | Read errors, reproduce, check changes, gather evidence | Understand WHAT and WHY |\n| **2. Pattern** | Find working examples, compare | Identify differences |\n| **3. Hypothesis** | Form theory, test minimally | Confirmed or new hypothesis |\n| **4. Implementation** | Create test, fix, verify | Bug resolved, tests pass |\n\n## When Process Reveals \"No Root Cause\"\n\nIf systematic investigation reveals issue is truly environmental, timing-dependent, or external:\n\n1. You've completed the process\n2. Document what you investigated\n3. Implement appropriate handling (retry, timeout, error message)\n4. Add monitoring/logging for future investigation\n\n**But:** 95% of \"no root cause\" cases are incomplete investigation.\n\n## Supporting Techniques\n\nThese techniques are part of systematic debugging and available in this directory:\n\n- **`root-cause-tracing.md`** - Trace bugs backward through call stack to find original trigger\n- **`defense-in-depth.md`** - Add validation at multiple layers after finding root cause\n- **`condition-based-waiting.md`** - Replace arbitrary timeouts with condition polling\n\n**Related skills:**\n- **superpowers:test-driven-development** - For creating failing test case (Phase 4, Step 1)\n- **superpowers:verification-before-completion** - Verify fix worked before claiming success\n\n## Real-World Impact\n\nFrom debugging sessions:\n- Systematic approach: 15-30 minutes to fix\n- Random fixes approach: 2-3 hours of thrashing\n- First-time fix rate: 95% vs 40%\n- New bugs introduced: Near zero vs common"
    },
    {
      "id": "obra-superpowers-test-driven-development",
      "name": "test-driven-development",
      "slug": "test-driven-development",
      "description": "Use when implementing any feature or bugfix, before writing implementation code",
      "category": "Quality",
      "platform": "Superpowers",
      "platformIcon": "‚ö°",
      "source": "obra/superpowers",
      "sourceUrl": "https://github.com/obra/superpowers/tree/main/skills/test-driven-development",
      "skillMdUrl": "https://raw.githubusercontent.com/obra/superpowers/main/skills/test-driven-development/SKILL.md",
      "body": "# Test-Driven Development (TDD)\n\n## Overview\n\nWrite the test first. Watch it fail. Write minimal code to pass.\n\n**Core principle:** If you didn't watch the test fail, you don't know if it tests the right thing.\n\n**Violating the letter of the rules is violating the spirit of the rules.**\n\n## When to Use\n\n**Always:**\n- New features\n- Bug fixes\n- Refactoring\n- Behavior changes\n\n**Exceptions (ask your human partner):**\n- Throwaway prototypes\n- Generated code\n- Configuration files\n\nThinking \"skip TDD just this once\"? Stop. That's rationalization.\n\n## The Iron Law\n\n```\nNO PRODUCTION CODE WITHOUT A FAILING TEST FIRST\n```\n\nWrite code before the test? Delete it. Start over.\n\n**No exceptions:**\n- Don't keep it as \"reference\"\n- Don't \"adapt\" it while writing tests\n- Don't look at it\n- Delete means delete\n\nImplement fresh from tests. Period.\n\n## Red-Green-Refactor\n\n```dot\ndigraph tdd_cycle {\n    rankdir=LR;\n    red [label=\"RED\\nWrite failing test\", shape=box, style=filled, fillcolor=\"#ffcccc\"];\n    verify_red [label=\"Verify fails\\ncorrectly\", shape=diamond];\n    green [label=\"GREEN\\nMinimal code\", shape=box, style=filled, fillcolor=\"#ccffcc\"];\n    verify_green [label=\"Verify passes\\nAll green\", shape=diamond];\n    refactor [label=\"REFACTOR\\nClean up\", shape=box, style=filled, fillcolor=\"#ccccff\"];\n    next [label=\"Next\", shape=ellipse];\n\n    red -> verify_red;\n    verify_red -> green [label=\"yes\"];\n    verify_red -> red [label=\"wrong\\nfailure\"];\n    green -> verify_green;\n    verify_green -> refactor [label=\"yes\"];\n    verify_green -> green [label=\"no\"];\n    refactor -> verify_green [label=\"stay\\ngreen\"];\n    verify_green -> next;\n    next -> red;\n}\n```\n\n### RED - Write Failing Test\n\nWrite one minimal test showing what should happen.\n\n<Good>\n```typescript\ntest('retries failed operations 3 times', async () => {\n  let attempts = 0;\n  const operation = () => {\n    attempts++;\n    if (attempts < 3) throw new Error('fail');\n    return 'success';\n  };\n\n  const result = await retryOperation(operation);\n\n  expect(result).toBe('success');\n  expect(attempts).toBe(3);\n});\n```\nClear name, tests real behavior, one thing\n</Good>\n\n<Bad>\n```typescript\ntest('retry works', async () => {\n  const mock = jest.fn()\n    .mockRejectedValueOnce(new Error())\n    .mockRejectedValueOnce(new Error())\n    .mockResolvedValueOnce('success');\n  await retryOperation(mock);\n  expect(mock).toHaveBeenCalledTimes(3);\n});\n```\nVague name, tests mock not code\n</Bad>\n\n**Requirements:**\n- One behavior\n- Clear name\n- Real code (no mocks unless unavoidable)\n\n### Verify RED - Watch It Fail\n\n**MANDATORY. Never skip.**\n\n```bash\nnpm test path/to/test.test.ts\n```\n\nConfirm:\n- Test fails (not errors)\n- Failure message is expected\n- Fails because feature missing (not typos)\n\n**Test passes?** You're testing existing behavior. Fix test.\n\n**Test errors?** Fix error, re-run until it fails correctly.\n\n### GREEN - Minimal Code\n\nWrite simplest code to pass the test.\n\n<Good>\n```typescript\nasync function retryOperation<T>(fn: () => Promise<T>): Promise<T> {\n  for (let i = 0; i < 3; i++) {\n    try {\n      return await fn();\n    } catch (e) {\n      if (i === 2) throw e;\n    }\n  }\n  throw new Error('unreachable');\n}\n```\nJust enough to pass\n</Good>\n\n<Bad>\n```typescript\nasync function retryOperation<T>(\n  fn: () => Promise<T>,\n  options?: {\n    maxRetries?: number;\n    backoff?: 'linear' | 'exponential';\n    onRetry?: (attempt: number) => void;\n  }\n): Promise<T> {\n  // YAGNI\n}\n```\nOver-engineered\n</Bad>\n\nDon't add features, refactor other code, or \"improve\" beyond the test.\n\n### Verify GREEN - Watch It Pass\n\n**MANDATORY.**\n\n```bash\nnpm test path/to/test.test.ts\n```\n\nConfirm:\n- Test passes\n- Other tests still pass\n- Output pristine (no errors, warnings)\n\n**Test fails?** Fix code, not test.\n\n**Other tests fail?** Fix now.\n\n### REFACTOR - Clean Up\n\nAfter green only:\n- Remove duplication\n- Improve names\n- Extract helpers\n\nKeep tests green. Don't add behavior.\n\n### Repeat\n\nNext failing test for next feature.\n\n## Good Tests\n\n| Quality | Good | Bad |\n|---------|------|-----|\n| **Minimal** | One thing. \"and\" in name? Split it. | `test('validates email and domain and whitespace')` |\n| **Clear** | Name describes behavior | `test('test1')` |\n| **Shows intent** | Demonstrates desired API | Obscures what code should do |\n\n## Why Order Matters\n\n**\"I'll write tests after to verify it works\"**\n\nTests written after code pass immediately. Passing immediately proves nothing:\n- Might test wrong thing\n- Might test implementation, not behavior\n- Might miss edge cases you forgot\n- You never saw it catch the bug\n\nTest-first forces you to see the test fail, proving it actually tests something.\n\n**\"I already manually tested all the edge cases\"**\n\nManual testing is ad-hoc. You think you tested everything but:\n- No record of what you tested\n- Can't re-run when code changes\n- Easy to forget cases under pressure\n- \"It worked when I tried it\" ‚â† comprehensive\n\nAutomated tests are systematic. They run the same way every time.\n\n**\"Deleting X hours of work is wasteful\"**\n\nSunk cost fallacy. The time is already gone. Your choice now:\n- Delete and rewrite with TDD (X more hours, high confidence)\n- Keep it and add tests after (30 min, low confidence, likely bugs)\n\nThe \"waste\" is keeping code you can't trust. Working code without real tests is technical debt.\n\n**\"TDD is dogmatic, being pragmatic means adapting\"**\n\nTDD IS pragmatic:\n- Finds bugs before commit (faster than debugging after)\n- Prevents regressions (tests catch breaks immediately)\n- Documents behavior (tests show how to use code)\n- Enables refactoring (change freely, tests catch breaks)\n\n\"Pragmatic\" shortcuts = debugging in production = slower.\n\n**\"Tests after achieve the same goals - it's spirit not ritual\"**\n\nNo. Tests-after answer \"What does this do?\" Tests-first answer \"What should this do?\"\n\nTests-after are biased by your implementation. You test what you built, not what's required. You verify remembered edge cases, not discovered ones.\n\nTests-first force edge case discovery before implementing. Tests-after verify you remembered everything (you didn't).\n\n30 minutes of tests after ‚â† TDD. You get coverage, lose proof tests work.\n\n## Common Rationalizations\n\n| Excuse | Reality |\n|--------|---------|\n| \"Too simple to test\" | Simple code breaks. Test takes 30 seconds. |\n| \"I'll test after\" | Tests passing immediately prove nothing. |\n| \"Tests after achieve same goals\" | Tests-after = \"what does this do?\" Tests-first = \"what should this do?\" |\n| \"Already manually tested\" | Ad-hoc ‚â† systematic. No record, can't re-run. |\n| \"Deleting X hours is wasteful\" | Sunk cost fallacy. Keeping unverified code is technical debt. |\n| \"Keep as reference, write tests first\" | You'll adapt it. That's testing after. Delete means delete. |\n| \"Need to explore first\" | Fine. Throw away exploration, start with TDD. |\n| \"Test hard = design unclear\" | Listen to test. Hard to test = hard to use. |\n| \"TDD will slow me down\" | TDD faster than debugging. Pragmatic = test-first. |\n| \"Manual test faster\" | Manual doesn't prove edge cases. You'll re-test every change. |\n| \"Existing code has no tests\" | You're improving it. Add tests for existing code. |\n\n## Red Flags - STOP and Start Over\n\n- Code before test\n- Test after implementation\n- Test passes immediately\n- Can't explain why test failed\n- Tests added \"later\"\n- Rationalizing \"just this once\"\n- \"I already manually tested it\"\n- \"Tests after achieve the same purpose\"\n- \"It's about spirit not ritual\"\n- \"Keep as reference\" or \"adapt existing code\"\n- \"Already spent X hours, deleting is wasteful\"\n- \"TDD is dogmatic, I'm being pragmatic\"\n- \"This is different because...\"\n\n**All of these mean: Delete code. Start over with TDD.**\n\n## Example: Bug Fix\n\n**Bug:** Empty email accepted\n\n**RED**\n```typescript\ntest('rejects empty email', async () => {\n  const result = await submitForm({ email: '' });\n  expect(result.error).toBe('Email required');\n});\n```\n\n**Verify RED**\n```bash\n$ npm test\nFAIL: expected 'Email required', got undefined\n```\n\n**GREEN**\n```typescript\nfunction submitForm(data: FormData) {\n  if (!data.email?.trim()) {\n    return { error: 'Email required' };\n  }\n  // ...\n}\n```\n\n**Verify GREEN**\n```bash\n$ npm test\nPASS\n```\n\n**REFACTOR**\nExtract validation for multiple fields if needed.\n\n## Verification Checklist\n\nBefore marking work complete:\n\n- [ ] Every new function/method has a test\n- [ ] Watched each test fail before implementing\n- [ ] Each test failed for expected reason (feature missing, not typo)\n- [ ] Wrote minimal code to pass each test\n- [ ] All tests pass\n- [ ] Output pristine (no errors, warnings)\n- [ ] Tests use real code (mocks only if unavoidable)\n- [ ] Edge cases and errors covered\n\nCan't check all boxes? You skipped TDD. Start over.\n\n## When Stuck\n\n| Problem | Solution |\n|---------|----------|\n| Don't know how to test | Write wished-for API. Write assertion first. Ask your human partner. |\n| Test too complicated | Design too complicated. Simplify interface. |\n| Must mock everything | Code too coupled. Use dependency injection. |\n| Test setup huge | Extract helpers. Still complex? Simplify design. |\n\n## Debugging Integration\n\nBug found? Write failing test reproducing it. Follow TDD cycle. Test proves fix and prevents regression.\n\nNever fix bugs without a test.\n\n## Testing Anti-Patterns\n\nWhen adding mocks or test utilities, read @testing-anti-patterns.md to avoid common pitfalls:\n- Testing mock behavior instead of real behavior\n- Adding test-only methods to production classes\n- Mocking without understanding dependencies\n\n## Final Rule\n\n```\nProduction code ‚Üí test exists and failed first\nOtherwise ‚Üí not TDD\n```\n\nNo exceptions without your human partner's permission."
    },
    {
      "id": "muratcankoylan-Agent-Skills-for-Context-Engineering-researcher",
      "name": "The Infinite Software Crisis ‚Äì Jake Nations, Netflix",
      "slug": "researcher",
      "description": "**Evaluation ID:** `a7f3c8e1-4b2d-4f9a-8c1e-3d5f7a9b2c4e`",
      "category": "General",
      "platform": "Context Engineering",
      "platformIcon": "üß†",
      "source": "muratcankoylan/Agent-Skills-for-Context-Engineering",
      "sourceUrl": "https://github.com/muratcankoylan/Agent-Skills-for-Context-Engineering/tree/main/researcher",
      "skillMdUrl": "https://raw.githubusercontent.com/muratcankoylan/Agent-Skills-for-Context-Engineering/main/researcher/example_output.md",
      "body": "# The Infinite Software Crisis ‚Äì Jake Nations, Netflix\n\n**Evaluation ID:** `a7f3c8e1-4b2d-4f9a-8c1e-3d5f7a9b2c4e`\n**Timestamp:** 2025-01-10T14:32:00Z\n**Source:**\n* **URL:** [AI Summit 2025 - Context Compression Talk](https://www.youtube.com/watch?v=eIoohUmYpGI&t=5s)\n* **Title:** Understanding Systems Before Automating: Context Compression and the Three-Phase Workflow\n* **Author:** Netflix Engineering (speaker unnamed in transcript)\n* **Type:** engineering_blog\n\n---\n\n## Gatekeeper Analysis\n\n* **G1 Mechanism Specificity:** **PASS**\n    * *Evidence:* Defines explicit three-phase mechanism: Research (analyze codebase, map dependencies, produce research document) ‚Üí Planning (function signatures, type definitions, data flow, 'paint by numbers' spec) ‚Üí Implementation (execute against specification with background agents). Also introduces 'context compression' as specific pattern: 5M tokens ‚Üí 2,000 words of specification.\n* **G2 Implementable Artifacts:** **PASS**\n    * *Evidence:* Describes concrete workflow structure: research phase outputs 'a single research document'; planning phase produces 'function signatures, type definitions, data flow'; human checkpoints at phase boundaries. Provides example workflow for authorization refactor showing manual migration PR used as research seed. While no code snippets, the methodology structure is specific enough to implement.\n* **G3 Beyond Basics:** **PASS**\n    * *Evidence:* Addresses advanced patterns: multi-phase agent orchestration with human validation, context compression for 5M+ token codebases, distinction between essential/accidental complexity for AI, using manual work artifacts as research seeds, pattern recognition atrophy in AI-assisted development.\n* **G4 Source Verifiability:** **PASS**\n    * *Evidence:* Speaker explicitly states: 'I spent the last few years at Netflix helping drive adoption of AI tools.' References production codebase of 'around a million lines of Java' and '5 million tokens' in main service. Discus"
    },
    {
      "id": "obra-superpowers-using-git-worktrees",
      "name": "using-git-worktrees",
      "slug": "using-git-worktrees",
      "description": "Use when starting feature work that needs isolation from current workspace or before executing implementation plans - creates isolated git worktrees with smart directory selection and safety verification",
      "category": "Git & Workflow",
      "platform": "Superpowers",
      "platformIcon": "‚ö°",
      "source": "obra/superpowers",
      "sourceUrl": "https://github.com/obra/superpowers/tree/main/skills/using-git-worktrees",
      "skillMdUrl": "https://raw.githubusercontent.com/obra/superpowers/main/skills/using-git-worktrees/SKILL.md",
      "body": "# Using Git Worktrees\n\n## Overview\n\nGit worktrees create isolated workspaces sharing the same repository, allowing work on multiple branches simultaneously without switching.\n\n**Core principle:** Systematic directory selection + safety verification = reliable isolation.\n\n**Announce at start:** \"I'm using the using-git-worktrees skill to set up an isolated workspace.\"\n\n## Directory Selection Process\n\nFollow this priority order:\n\n### 1. Check Existing Directories\n\n```bash\n# Check in priority order\nls -d .worktrees 2>/dev/null     # Preferred (hidden)\nls -d worktrees 2>/dev/null      # Alternative\n```\n\n**If found:** Use that directory. If both exist, `.worktrees` wins.\n\n### 2. Check CLAUDE.md\n\n```bash\ngrep -i \"worktree.*director\" CLAUDE.md 2>/dev/null\n```\n\n**If preference specified:** Use it without asking.\n\n### 3. Ask User\n\nIf no directory exists and no CLAUDE.md preference:\n\n```\nNo worktree directory found. Where should I create worktrees?\n\n1. .worktrees/ (project-local, hidden)\n2. ~/.config/superpowers/worktrees/<project-name>/ (global location)\n\nWhich would you prefer?\n```\n\n## Safety Verification\n\n### For Project-Local Directories (.worktrees or worktrees)\n\n**MUST verify directory is ignored before creating worktree:**\n\n```bash\n# Check if directory is ignored (respects local, global, and system gitignore)\ngit check-ignore -q .worktrees 2>/dev/null || git check-ignore -q worktrees 2>/dev/null\n```\n\n**If NOT ignored:**\n\nPer Jesse's rule \"Fix broken things immediately\":\n1. Add appropriate line to .gitignore\n2. Commit the change\n3. Proceed with worktree creation\n\n**Why critical:** Prevents accidentally committing worktree contents to repository.\n\n### For Global Directory (~/.config/superpowers/worktrees)\n\nNo .gitignore verification needed - outside project entirely.\n\n## Creation Steps\n\n### 1. Detect Project Name\n\n```bash\nproject=$(basename \"$(git rev-parse --show-toplevel)\")\n```\n\n### 2. Create Worktree\n\n```bash\n# Determine full path\ncase $LOCATION in\n  .worktrees|worktrees)\n    path=\"$LOCATION/$BRANCH_NAME\"\n    ;;\n  ~/.config/superpowers/worktrees/*)\n    path=\"~/.config/superpowers/worktrees/$project/$BRANCH_NAME\"\n    ;;\nesac\n\n# Create worktree with new branch\ngit worktree add \"$path\" -b \"$BRANCH_NAME\"\ncd \"$path\"\n```\n\n### 3. Run Project Setup\n\nAuto-detect and run appropriate setup:\n\n```bash\n# Node.js\nif [ -f package.json ]; then npm install; fi\n\n# Rust\nif [ -f Cargo.toml ]; then cargo build; fi\n\n# Python\nif [ -f requirements.txt ]; then pip install -r requirements.txt; fi\nif [ -f pyproject.toml ]; then poetry install; fi\n\n# Go\nif [ -f go.mod ]; then go mod download; fi\n```\n\n### 4. Verify Clean Baseline\n\nRun tests to ensure worktree starts clean:\n\n```bash\n# Examples - use project-appropriate command\nnpm test\ncargo test\npytest\ngo test ./...\n```\n\n**If tests fail:** Report failures, ask whether to proceed or investigate.\n\n**If tests pass:** Report ready.\n\n### 5. Report Location\n\n```\nWorktree ready at <full-path>\nTests passing (<N> tests, 0 failures)\nReady to implement <feature-name>\n```\n\n## Quick Reference\n\n| Situation | Action |\n|-----------|--------|\n| `.worktrees/` exists | Use it (verify ignored) |\n| `worktrees/` exists | Use it (verify ignored) |\n| Both exist | Use `.worktrees/` |\n| Neither exists | Check CLAUDE.md ‚Üí Ask user |\n| Directory not ignored | Add to .gitignore + commit |\n| Tests fail during baseline | Report failures + ask |\n| No package.json/Cargo.toml | Skip dependency install |\n\n## Common Mistakes\n\n### Skipping ignore verification\n\n- **Problem:** Worktree contents get tracked, pollute git status\n- **Fix:** Always use `git check-ignore` before creating project-local worktree\n\n### Assuming directory location\n\n- **Problem:** Creates inconsistency, violates project conventions\n- **Fix:** Follow priority: existing > CLAUDE.md > ask\n\n### Proceeding with failing tests\n\n- **Problem:** Can't distinguish new bugs from pre-existing issues\n- **Fix:** Report failures, get explicit permission to proceed\n\n### Hardcoding setup commands\n\n- **Problem:** Breaks on projects using different tools\n- **Fix:** Auto-detect from project files (package.json, etc.)\n\n## Example Workflow\n\n```\nYou: I'm using the using-git-worktrees skill to set up an isolated workspace.\n\n[Check .worktrees/ - exists]\n[Verify ignored - git check-ignore confirms .worktrees/ is ignored]\n[Create worktree: git worktree add .worktrees/auth -b feature/auth]\n[Run npm install]\n[Run npm test - 47 passing]\n\nWorktree ready at /Users/jesse/myproject/.worktrees/auth\nTests passing (47 tests, 0 failures)\nReady to implement auth feature\n```\n\n## Red Flags\n\n**Never:**\n- Create worktree without verifying it's ignored (project-local)\n- Skip baseline test verification\n- Proceed with failing tests without asking\n- Assume directory location when ambiguous\n- Skip CLAUDE.md check\n\n**Always:**\n- Follow directory priority: existing > CLAUDE.md > ask\n- Verify directory is ignored for project-local\n- Auto-detect and run project setup\n- Verify clean test baseline\n\n## Integration\n\n**Called by:**\n- **brainstorming** (Phase 4) - REQUIRED when design is approved and implementation follows\n- **subagent-driven-development** - REQUIRED before executing any tasks\n- **executing-plans** - REQUIRED before executing any tasks\n- Any skill needing isolated workspace\n\n**Pairs with:**\n- **finishing-a-development-branch** - REQUIRED for cleanup after work complete"
    },
    {
      "id": "obra-superpowers-using-superpowers",
      "name": "using-superpowers",
      "slug": "using-superpowers",
      "description": "Use when starting any conversation - establishes how to find and use skills, requiring Skill tool invocation before ANY response including clarifying questions",
      "category": "Tools",
      "platform": "Superpowers",
      "platformIcon": "‚ö°",
      "source": "obra/superpowers",
      "sourceUrl": "https://github.com/obra/superpowers/tree/main/skills/using-superpowers",
      "skillMdUrl": "https://raw.githubusercontent.com/obra/superpowers/main/skills/using-superpowers/SKILL.md",
      "body": "<EXTREMELY-IMPORTANT>\nIf you think there is even a 1% chance a skill might apply to what you are doing, you ABSOLUTELY MUST invoke the skill.\n\nIF A SKILL APPLIES TO YOUR TASK, YOU DO NOT HAVE A CHOICE. YOU MUST USE IT.\n\nThis is not negotiable. This is not optional. You cannot rationalize your way out of this.\n</EXTREMELY-IMPORTANT>\n\n## How to Access Skills\n\n**In Claude Code:** Use the `Skill` tool. When you invoke a skill, its content is loaded and presented to you‚Äîfollow it directly. Never use the Read tool on skill files.\n\n**In other environments:** Check your platform's documentation for how skills are loaded.\n\n# Using Skills\n\n## The Rule\n\n**Invoke relevant or requested skills BEFORE any response or action.** Even a 1% chance a skill might apply means that you should invoke the skill to check. If an invoked skill turns out to be wrong for the situation, you don't need to use it.\n\n```dot\ndigraph skill_flow {\n    \"User message received\" [shape=doublecircle];\n    \"About to EnterPlanMode?\" [shape=doublecircle];\n    \"Already brainstormed?\" [shape=diamond];\n    \"Invoke brainstorming skill\" [shape=box];\n    \"Might any skill apply?\" [shape=diamond];\n    \"Invoke Skill tool\" [shape=box];\n    \"Announce: 'Using [skill] to [purpose]'\" [shape=box];\n    \"Has checklist?\" [shape=diamond];\n    \"Create TodoWrite todo per item\" [shape=box];\n    \"Follow skill exactly\" [shape=box];\n    \"Respond (including clarifications)\" [shape=doublecircle];\n\n    \"About to EnterPlanMode?\" -> \"Already brainstormed?\";\n    \"Already brainstormed?\" -> \"Invoke brainstorming skill\" [label=\"no\"];\n    \"Already brainstormed?\" -> \"Might any skill apply?\" [label=\"yes\"];\n    \"Invoke brainstorming skill\" -> \"Might any skill apply?\";\n\n    \"User message received\" -> \"Might any skill apply?\";\n    \"Might any skill apply?\" -> \"Invoke Skill tool\" [label=\"yes, even 1%\"];\n    \"Might any skill apply?\" -> \"Respond (including clarifications)\" [label=\"definitely not\"];\n    \"Invoke Skill tool\" -> \"Announce: 'Using [skill] to [purpose]'\";\n    \"Announce: 'Using [skill] to [purpose]'\" -> \"Has checklist?\";\n    \"Has checklist?\" -> \"Create TodoWrite todo per item\" [label=\"yes\"];\n    \"Has checklist?\" -> \"Follow skill exactly\" [label=\"no\"];\n    \"Create TodoWrite todo per item\" -> \"Follow skill exactly\";\n}\n```\n\n## Red Flags\n\nThese thoughts mean STOP‚Äîyou're rationalizing:\n\n| Thought | Reality |\n|---------|---------|\n| \"This is just a simple question\" | Questions are tasks. Check for skills. |\n| \"I need more context first\" | Skill check comes BEFORE clarifying questions. |\n| \"Let me explore the codebase first\" | Skills tell you HOW to explore. Check first. |\n| \"I can check git/files quickly\" | Files lack conversation context. Check for skills. |\n| \"Let me gather information first\" | Skills tell you HOW to gather information. |\n| \"This doesn't need a formal skill\" | If a skill exists, use it. |\n| \"I remember this skill\" | Skills evolve. Read current version. |\n| \"This doesn't count as a task\" | Action = task. Check for skills. |\n| \"The skill is overkill\" | Simple things become complex. Use it. |\n| \"I'll just do this one thing first\" | Check BEFORE doing anything. |\n| \"This feels productive\" | Undisciplined action wastes time. Skills prevent this. |\n| \"I know what that means\" | Knowing the concept ‚â† using the skill. Invoke it. |\n\n## Skill Priority\n\nWhen multiple skills could apply, use this order:\n\n1. **Process skills first** (brainstorming, debugging) - these determine HOW to approach the task\n2. **Implementation skills second** (frontend-design, mcp-builder) - these guide execution\n\n\"Let's build X\" ‚Üí brainstorming first, then implementation skills.\n\"Fix this bug\" ‚Üí debugging first, then domain-specific skills.\n\n## Skill Types\n\n**Rigid** (TDD, debugging): Follow exactly. Don't adapt away discipline.\n\n**Flexible** (patterns): Adapt principles to context.\n\nThe skill itself tells you which.\n\n## User Instructions\n\nInstructions say WHAT, not HOW. \"Add X\" or \"Fix Y\" doesn't mean skip workflows."
    },
    {
      "id": "obra-superpowers-verification-before-completion",
      "name": "verification-before-completion",
      "slug": "verification-before-completion",
      "description": "Use when about to claim work is complete, fixed, or passing, before committing or creating PRs - requires running verification commands and confirming output before making any success claims; evidence before assertions always",
      "category": "Git & Workflow",
      "platform": "Superpowers",
      "platformIcon": "‚ö°",
      "source": "obra/superpowers",
      "sourceUrl": "https://github.com/obra/superpowers/tree/main/skills/verification-before-completion",
      "skillMdUrl": "https://raw.githubusercontent.com/obra/superpowers/main/skills/verification-before-completion/SKILL.md",
      "body": "# Verification Before Completion\n\n## Overview\n\nClaiming work is complete without verification is dishonesty, not efficiency.\n\n**Core principle:** Evidence before claims, always.\n\n**Violating the letter of this rule is violating the spirit of this rule.**\n\n## The Iron Law\n\n```\nNO COMPLETION CLAIMS WITHOUT FRESH VERIFICATION EVIDENCE\n```\n\nIf you haven't run the verification command in this message, you cannot claim it passes.\n\n## The Gate Function\n\n```\nBEFORE claiming any status or expressing satisfaction:\n\n1. IDENTIFY: What command proves this claim?\n2. RUN: Execute the FULL command (fresh, complete)\n3. READ: Full output, check exit code, count failures\n4. VERIFY: Does output confirm the claim?\n   - If NO: State actual status with evidence\n   - If YES: State claim WITH evidence\n5. ONLY THEN: Make the claim\n\nSkip any step = lying, not verifying\n```\n\n## Common Failures\n\n| Claim | Requires | Not Sufficient |\n|-------|----------|----------------|\n| Tests pass | Test command output: 0 failures | Previous run, \"should pass\" |\n| Linter clean | Linter output: 0 errors | Partial check, extrapolation |\n| Build succeeds | Build command: exit 0 | Linter passing, logs look good |\n| Bug fixed | Test original symptom: passes | Code changed, assumed fixed |\n| Regression test works | Red-green cycle verified | Test passes once |\n| Agent completed | VCS diff shows changes | Agent reports \"success\" |\n| Requirements met | Line-by-line checklist | Tests passing |\n\n## Red Flags - STOP\n\n- Using \"should\", \"probably\", \"seems to\"\n- Expressing satisfaction before verification (\"Great!\", \"Perfect!\", \"Done!\", etc.)\n- About to commit/push/PR without verification\n- Trusting agent success reports\n- Relying on partial verification\n- Thinking \"just this once\"\n- Tired and wanting work over\n- **ANY wording implying success without having run verification**\n\n## Rationalization Prevention\n\n| Excuse | Reality |\n|--------|---------|\n| \"Should work now\" | RUN the verification |\n| \"I'm confident\" | Confidence ‚â† evidence |\n| \"Just this once\" | No exceptions |\n| \"Linter passed\" | Linter ‚â† compiler |\n| \"Agent said success\" | Verify independently |\n| \"I'm tired\" | Exhaustion ‚â† excuse |\n| \"Partial check is enough\" | Partial proves nothing |\n| \"Different words so rule doesn't apply\" | Spirit over letter |\n\n## Key Patterns\n\n**Tests:**\n```\n‚úÖ [Run test command] [See: 34/34 pass] \"All tests pass\"\n‚ùå \"Should pass now\" / \"Looks correct\"\n```\n\n**Regression tests (TDD Red-Green):**\n```\n‚úÖ Write ‚Üí Run (pass) ‚Üí Revert fix ‚Üí Run (MUST FAIL) ‚Üí Restore ‚Üí Run (pass)\n‚ùå \"I've written a regression test\" (without red-green verification)\n```\n\n**Build:**\n```\n‚úÖ [Run build] [See: exit 0] \"Build passes\"\n‚ùå \"Linter passed\" (linter doesn't check compilation)\n```\n\n**Requirements:**\n```\n‚úÖ Re-read plan ‚Üí Create checklist ‚Üí Verify each ‚Üí Report gaps or completion\n‚ùå \"Tests pass, phase complete\"\n```\n\n**Agent delegation:**\n```\n‚úÖ Agent reports success ‚Üí Check VCS diff ‚Üí Verify changes ‚Üí Report actual state\n‚ùå Trust agent report\n```\n\n## Why This Matters\n\nFrom 24 failure memories:\n- your human partner said \"I don't believe you\" - trust broken\n- Undefined functions shipped - would crash\n- Missing requirements shipped - incomplete features\n- Time wasted on false completion ‚Üí redirect ‚Üí rework\n- Violates: \"Honesty is a core value. If you lie, you'll be replaced.\"\n\n## When To Apply\n\n**ALWAYS before:**\n- ANY variation of success/completion claims\n- ANY expression of satisfaction\n- ANY positive statement about work state\n- Committing, PR creation, task completion\n- Moving to next task\n- Delegating to agents\n\n**Rule applies to:**\n- Exact phrases\n- Paraphrases and synonyms\n- Implications of success\n- ANY communication suggesting completion/correctness\n\n## The Bottom Line\n\n**No shortcuts for verification.**\n\nRun the command. Read the output. THEN claim the result.\n\nThis is non-negotiable."
    },
    {
      "id": "obra-superpowers-writing-plans",
      "name": "writing-plans",
      "slug": "writing-plans",
      "description": "Use when you have a spec or requirements for a multi-step task, before touching code",
      "category": "Planning",
      "platform": "Superpowers",
      "platformIcon": "‚ö°",
      "source": "obra/superpowers",
      "sourceUrl": "https://github.com/obra/superpowers/tree/main/skills/writing-plans",
      "skillMdUrl": "https://raw.githubusercontent.com/obra/superpowers/main/skills/writing-plans/SKILL.md",
      "body": "# Writing Plans\n\n## Overview\n\nWrite comprehensive implementation plans assuming the engineer has zero context for our codebase and questionable taste. Document everything they need to know: which files to touch for each task, code, testing, docs they might need to check, how to test it. Give them the whole plan as bite-sized tasks. DRY. YAGNI. TDD. Frequent commits.\n\nAssume they are a skilled developer, but know almost nothing about our toolset or problem domain. Assume they don't know good test design very well.\n\n**Announce at start:** \"I'm using the writing-plans skill to create the implementation plan.\"\n\n**Context:** This should be run in a dedicated worktree (created by brainstorming skill).\n\n**Save plans to:** `docs/plans/YYYY-MM-DD-<feature-name>.md`\n\n## Bite-Sized Task Granularity\n\n**Each step is one action (2-5 minutes):**\n- \"Write the failing test\" - step\n- \"Run it to make sure it fails\" - step\n- \"Implement the minimal code to make the test pass\" - step\n- \"Run the tests and make sure they pass\" - step\n- \"Commit\" - step\n\n## Plan Document Header\n\n**Every plan MUST start with this header:**\n\n```markdown\n# [Feature Name] Implementation Plan\n\n> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.\n\n**Goal:** [One sentence describing what this builds]\n\n**Architecture:** [2-3 sentences about approach]\n\n**Tech Stack:** [Key technologies/libraries]\n\n---\n```\n\n## Task Structure\n\n````markdown\n### Task N: [Component Name]\n\n**Files:**\n- Create: `exact/path/to/file.py`\n- Modify: `exact/path/to/existing.py:123-145`\n- Test: `tests/exact/path/to/test.py`\n\n**Step 1: Write the failing test**\n\n```python\ndef test_specific_behavior():\n    result = function(input)\n    assert result == expected\n```\n\n**Step 2: Run test to verify it fails**\n\nRun: `pytest tests/path/test.py::test_name -v`\nExpected: FAIL with \"function not defined\"\n\n**Step 3: Write minimal implementation**\n\n```python\ndef function(input):\n    return expected\n```\n\n**Step 4: Run test to verify it passes**\n\nRun: `pytest tests/path/test.py::test_name -v`\nExpected: PASS\n\n**Step 5: Commit**\n\n```bash\ngit add tests/path/test.py src/path/file.py\ngit commit -m \"feat: add specific feature\"\n```\n````\n\n## Remember\n- Exact file paths always\n- Complete code in plan (not \"add validation\")\n- Exact commands with expected output\n- Reference relevant skills with @ syntax\n- DRY, YAGNI, TDD, frequent commits\n\n## Execution Handoff\n\nAfter saving the plan, offer execution choice:\n\n**\"Plan complete and saved to `docs/plans/<filename>.md`. Two execution options:**\n\n**1. Subagent-Driven (this session)** - I dispatch fresh subagent per task, review between tasks, fast iteration\n\n**2. Parallel Session (separate)** - Open new session with executing-plans, batch execution with checkpoints\n\n**Which approach?\"**\n\n**If Subagent-Driven chosen:**\n- **REQUIRED SUB-SKILL:** Use superpowers:subagent-driven-development\n- Stay in this session\n- Fresh subagent per task + code review\n\n**If Parallel Session chosen:**\n- Guide them to open new session in worktree\n- **REQUIRED SUB-SKILL:** New session uses superpowers:executing-plans"
    },
    {
      "id": "obra-superpowers-writing-skills",
      "name": "writing-skills",
      "slug": "writing-skills",
      "description": "Use when creating new skills, editing existing skills, or verifying skills work before deployment",
      "category": "Quality",
      "platform": "Superpowers",
      "platformIcon": "‚ö°",
      "source": "obra/superpowers",
      "sourceUrl": "https://github.com/obra/superpowers/tree/main/skills/writing-skills",
      "skillMdUrl": "https://raw.githubusercontent.com/obra/superpowers/main/skills/writing-skills/SKILL.md",
      "body": "# Writing Skills\n\n## Overview\n\n**Writing skills IS Test-Driven Development applied to process documentation.**\n\n**Personal skills live in agent-specific directories (`~/.claude/skills` for Claude Code, `~/.agents/skills/` for Codex)** \n\nYou write test cases (pressure scenarios with subagents), watch them fail (baseline behavior), write the skill (documentation), watch tests pass (agents comply), and refactor (close loopholes).\n\n**Core principle:** If you didn't watch an agent fail without the skill, you don't know if the skill teaches the right thing.\n\n**REQUIRED BACKGROUND:** You MUST understand superpowers:test-driven-development before using this skill. That skill defines the fundamental RED-GREEN-REFACTOR cycle. This skill adapts TDD to documentation.\n\n**Official guidance:** For Anthropic's official skill authoring best practices, see anthropic-best-practices.md. This document provides additional patterns and guidelines that complement the TDD-focused approach in this skill.\n\n## What is a Skill?\n\nA **skill** is a reference guide for proven techniques, patterns, or tools. Skills help future Claude instances find and apply effective approaches.\n\n**Skills are:** Reusable techniques, patterns, tools, reference guides\n\n**Skills are NOT:** Narratives about how you solved a problem once\n\n## TDD Mapping for Skills\n\n| TDD Concept | Skill Creation |\n|-------------|----------------|\n| **Test case** | Pressure scenario with subagent |\n| **Production code** | Skill document (SKILL.md) |\n| **Test fails (RED)** | Agent violates rule without skill (baseline) |\n| **Test passes (GREEN)** | Agent complies with skill present |\n| **Refactor** | Close loopholes while maintaining compliance |\n| **Write test first** | Run baseline scenario BEFORE writing skill |\n| **Watch it fail** | Document exact rationalizations agent uses |\n| **Minimal code** | Write skill addressing those specific violations |\n| **Watch it pass** | Verify agent now complies |\n| **Refactor cycle** | Find new rationalizations ‚Üí plug ‚Üí re-verify |\n\nThe entire skill creation process follows RED-GREEN-REFACTOR.\n\n## When to Create a Skill\n\n**Create when:**\n- Technique wasn't intuitively obvious to you\n- You'd reference this again across projects\n- Pattern applies broadly (not project-specific)\n- Others would benefit\n\n**Don't create for:**\n- One-off solutions\n- Standard practices well-documented elsewhere\n- Project-specific conventions (put in CLAUDE.md)\n- Mechanical constraints (if it's enforceable with regex/validation, automate it‚Äîsave documentation for judgment calls)\n\n## Skill Types\n\n### Technique\nConcrete method with steps to follow (condition-based-waiting, root-cause-tracing)\n\n### Pattern\nWay of thinking about problems (flatten-with-flags, test-invariants)\n\n### Reference\nAPI docs, syntax guides, tool documentation (office docs)\n\n## Directory Structure\n\n\n```\nskills/\n  skill-name/\n    SKILL.md              # Main reference (required)\n    supporting-file.*     # Only if needed\n```\n\n**Flat namespace** - all skills in one searchable namespace\n\n**Separate files for:**\n1. **Heavy reference** (100+ lines) - API docs, comprehensive syntax\n2. **Reusable tools** - Scripts, utilities, templates\n\n**Keep inline:**\n- Principles and concepts\n- Code patterns (< 50 lines)\n- Everything else\n\n## SKILL.md Structure\n\n**Frontmatter (YAML):**\n- Only two fields supported: `name` and `description`\n- Max 1024 characters total\n- `name`: Use letters, numbers, and hyphens only (no parentheses, special chars)\n- `description`: Third-person, describes ONLY when to use (NOT what it does)\n  - Start with \"Use when...\" to focus on triggering conditions\n  - Include specific symptoms, situations, and contexts\n  - **NEVER summarize the skill's process or workflow** (see CSO section for why)\n  - Keep under 500 characters if possible\n\n```markdown\n---\nname: Skill-Name-With-Hyphens\ndescription: Use when [specific triggering conditions and symptoms]\n---\n\n# Skill Name\n\n## Overview\nWhat is this? Core principle in 1-2 sentences.\n\n## When to Use\n[Small inline flowchart IF decision non-obvious]\n\nBullet list with SYMPTOMS and use cases\nWhen NOT to use\n\n## Core Pattern (for techniques/patterns)\nBefore/after code comparison\n\n## Quick Reference\nTable or bullets for scanning common operations\n\n## Implementation\nInline code for simple patterns\nLink to file for heavy reference or reusable tools\n\n## Common Mistakes\nWhat goes wrong + fixes\n\n## Real-World Impact (optional)\nConcrete results\n```\n\n\n## Claude Search Optimization (CSO)\n\n**Critical for discovery:** Future Claude needs to FIND your skill\n\n### 1. Rich Description Field\n\n**Purpose:** Claude reads description to decide which skills to load for a given task. Make it answer: \"Should I read this skill right now?\"\n\n**Format:** Start with \"Use when...\" to focus on triggering conditions\n\n**CRITICAL: Description = When to Use, NOT What the Skill Does**\n\nThe description should ONLY describe triggering conditions. Do NOT summarize the skill's process or workflow in the description.\n\n**Why this matters:** Testing revealed that when a description summarizes the skill's workflow, Claude may follow the description instead of reading the full skill content. A description saying \"code review between tasks\" caused Claude to do ONE review, even though the skill's flowchart clearly showed TWO reviews (spec compliance then code quality).\n\nWhen the description was changed to just \"Use when executing implementation plans with independent tasks\" (no workflow summary), Claude correctly read the flowchart and followed the two-stage review process.\n\n**The trap:** Descriptions that summarize workflow create a shortcut Claude will take. The skill body becomes documentation Claude skips.\n\n```yaml\n# ‚ùå BAD: Summarizes workflow - Claude may follow this instead of reading skill\ndescription: Use when executing plans - dispatches subagent per task with code review between tasks\n\n# ‚ùå BAD: Too much process detail\ndescription: Use for TDD - write test first, watch it fail, write minimal code, refactor\n\n# ‚úÖ GOOD: Just triggering conditions, no workflow summary\ndescription: Use when executing implementation plans with independent tasks in the current session\n\n# ‚úÖ GOOD: Triggering conditions only\ndescription: Use when implementing any feature or bugfix, before writing implementation code\n```\n\n**Content:**\n- Use concrete triggers, symptoms, and situations that signal this skill applies\n- Describe the *problem* (race conditions, inconsistent behavior) not *language-specific symptoms* (setTimeout, sleep)\n- Keep triggers technology-agnostic unless the skill itself is technology-specific\n- If skill is technology-specific, make that explicit in the trigger\n- Write in third person (injected into system prompt)\n- **NEVER summarize the skill's process or workflow**\n\n```yaml\n# ‚ùå BAD: Too abstract, vague, doesn't include when to use\ndescription: For async testing\n\n# ‚ùå BAD: First person\ndescription: I can help you with async tests when they're flaky\n\n# ‚ùå BAD: Mentions technology but skill isn't specific to it\ndescription: Use when tests use setTimeout/sleep and are flaky\n\n# ‚úÖ GOOD: Starts with \"Use when\", describes problem, no workflow\ndescription: Use when tests have race conditions, timing dependencies, or pass/fail inconsistently\n\n# ‚úÖ GOOD: Technology-specific skill with explicit trigger\ndescription: Use when using React Router and handling authentication redirects\n```\n\n### 2. Keyword Coverage\n\nUse words Claude would search for:\n- Error messages: \"Hook timed out\", \"ENOTEMPTY\", \"race condition\"\n- Symptoms: \"flaky\", \"hanging\", \"zombie\", \"pollution\"\n- Synonyms: \"timeout/hang/freeze\", \"cleanup/teardown/afterEach\"\n- Tools: Actual commands, library names, file types\n\n### 3. Descriptive Naming\n\n**Use active voice, verb-first:**\n- ‚úÖ `creating-skills` not `skill-creation`\n- ‚úÖ `condition-based-waiting` not `async-test-helpers`\n\n### 4. Token Efficiency (Critical)\n\n**Problem:** getting-started and frequently-referenced skills load into EVERY conversation. Every token counts.\n\n**Target word counts:**\n- getting-started workflows: <150 words each\n- Frequently-loaded skills: <200 words total\n- Other skills: <500 words (still be concise)\n\n**Techniques:**\n\n**Move details to tool help:**\n```bash\n# ‚ùå BAD: Document all flags in SKILL.md\nsearch-conversations supports --text, --both, --after DATE, --before DATE, --limit N\n\n# ‚úÖ GOOD: Reference --help\nsearch-conversations supports multiple modes and filters. Run --help for details.\n```\n\n**Use cross-references:**\n```markdown\n# ‚ùå BAD: Repeat workflow details\nWhen searching, dispatch subagent with template...\n[20 lines of repeated instructions]\n\n# ‚úÖ GOOD: Reference other skill\nAlways use subagents (50-100x context savings). REQUIRED: Use [other-skill-name] for workflow.\n```\n\n**Compress examples:**\n```markdown\n# ‚ùå BAD: Verbose example (42 words)\nyour human partner: \"How did we handle authentication errors in React Router before?\"\nYou: I'll search past conversations for React Router authentication patterns.\n[Dispatch subagent with search query: \"React Router authentication error handling 401\"]\n\n# ‚úÖ GOOD: Minimal example (20 words)\nPartner: \"How did we handle auth errors in React Router?\"\nYou: Searching...\n[Dispatch subagent ‚Üí synthesis]\n```\n\n**Eliminate redundancy:**\n- Don't repeat what's in cross-referenced skills\n- Don't explain what's obvious from command\n- Don't include multiple examples of same pattern\n\n**Verification:**\n```bash\nwc -w skills/path/SKILL.md\n# getting-started workflows: aim for <150 each\n# Other frequently-loaded: aim for <200 total\n```\n\n**Name by what you DO or core insight:**\n- ‚úÖ `condition-based-waiting` > `async-test-helpers`\n- ‚úÖ `using-skills` not `skill-usage`\n- ‚úÖ `flatten-with-flags` > `data-structure-refactoring`\n- ‚úÖ `root-cause-tracing` > `debugging-techniques`\n\n**Gerunds (-ing) work well for processes:**\n- `creating-skills`, `testing-skills`, `debugging-with-logs`\n- Active, describes the action you're taking\n\n### 4. Cross-Referencing Other Skills\n\n**When writing documentation that references other skills:**\n\nUse skill name only, with explicit requirement markers:\n- ‚úÖ Good: `**REQUIRED SUB-SKILL:** Use superpowers:test-driven-development`\n- ‚úÖ Good: `**REQUIRED BACKGROUND:** You MUST understand superpowers:systematic-debugging`\n- ‚ùå Bad: `See skills/testing/test-driven-development` (unclear if required)\n- ‚ùå Bad: `@skills/testing/test-driven-development/SKILL.md` (force-loads, burns context)\n\n**Why no @ links:** `@` syntax force-loads files immediately, consuming 200k+ context before you need them.\n\n## Flowchart Usage\n\n```dot\ndigraph when_flowchart {\n    \"Need to show information?\" [shape=diamond];\n    \"Decision where I might go wrong?\" [shape=diamond];\n    \"Use markdown\" [shape=box];\n    \"Small inline flowchart\" [shape=box];\n\n    \"Need to show information?\" -> \"Decision where I might go wrong?\" [label=\"yes\"];\n    \"Decision where I might go wrong?\" -> \"Small inline flowchart\" [label=\"yes\"];\n    \"Decision where I might go wrong?\" -> \"Use markdown\" [label=\"no\"];\n}\n```\n\n**Use flowcharts ONLY for:**\n- Non-obvious decision points\n- Process loops where you might stop too early\n- \"When to use A vs B\" decisions\n\n**Never use flowcharts for:**\n- Reference material ‚Üí Tables, lists\n- Code examples ‚Üí Markdown blocks\n- Linear instructions ‚Üí Numbered lists\n- Labels without semantic meaning (step1, helper2)\n\nSee @graphviz-conventions.dot for graphviz style rules.\n\n**Visualizing for your human partner:** Use `render-graphs.js` in this directory to render a skill's flowcharts to SVG:\n```bash\n./render-graphs.js ../some-skill           # Each diagram separately\n./render-graphs.js ../some-skill --combine # All diagrams in one SVG\n```\n\n## Code Examples\n\n**One excellent example beats many mediocre ones**\n\nChoose most relevant language:\n- Testing techniques ‚Üí TypeScript/JavaScript\n- System debugging ‚Üí Shell/Python\n- Data processing ‚Üí Python\n\n**Good example:**\n- Complete and runnable\n- Well-commented explaining WHY\n- From real scenario\n- Shows pattern clearly\n- Ready to adapt (not generic template)\n\n**Don't:**\n- Implement in 5+ languages\n- Create fill-in-the-blank templates\n- Write contrived examples\n\nYou're good at porting - one great example is enough.\n\n## File Organization\n\n### Self-Contained Skill\n```\ndefense-in-depth/\n  SKILL.md    # Everything inline\n```\nWhen: All content fits, no heavy reference needed\n\n### Skill with Reusable Tool\n```\ncondition-based-waiting/\n  SKILL.md    # Overview + patterns\n  example.ts  # Working helpers to adapt\n```\nWhen: Tool is reusable code, not just narrative\n\n### Skill with Heavy Reference\n```\npptx/\n  SKILL.md       # Overview + workflows\n  pptxgenjs.md   # 600 lines API reference\n  ooxml.md       # 500 lines XML structure\n  scripts/       # Executable tools\n```\nWhen: Reference material too large for inline\n\n## The Iron Law (Same as TDD)\n\n```\nNO SKILL WITHOUT A FAILING TEST FIRST\n```\n\nThis applies to NEW skills AND EDITS to existing skills.\n\nWrite skill before testing? Delete it. Start over.\nEdit skill without testing? Same violation.\n\n**No exceptions:**\n- Not for \"simple additions\"\n- Not for \"just adding a section\"\n- Not for \"documentation updates\"\n- Don't keep untested changes as \"reference\"\n- Don't \"adapt\" while running tests\n- Delete means delete\n\n**REQUIRED BACKGROUND:** The superpowers:test-driven-development skill explains why this matters. Same principles apply to documentation.\n\n## Testing All Skill Types\n\nDifferent skill types need different test approaches:\n\n### Discipline-Enforcing Skills (rules/requirements)\n\n**Examples:** TDD, verification-before-completion, designing-before-coding\n\n**Test with:**\n- Academic questions: Do they understand the rules?\n- Pressure scenarios: Do they comply under stress?\n- Multiple pressures combined: time + sunk cost + exhaustion\n- Identify rationalizations and add explicit counters\n\n**Success criteria:** Agent follows rule under maximum pressure\n\n### Technique Skills (how-to guides)\n\n**Examples:** condition-based-waiting, root-cause-tracing, defensive-programming\n\n**Test with:**\n- Application scenarios: Can they apply the technique correctly?\n- Variation scenarios: Do they handle edge cases?\n- Missing information tests: Do instructions have gaps?\n\n**Success criteria:** Agent successfully applies technique to new scenario\n\n### Pattern Skills (mental models)\n\n**Examples:** reducing-complexity, information-hiding concepts\n\n**Test with:**\n- Recognition scenarios: Do they recognize when pattern applies?\n- Application scenarios: Can they use the mental model?\n- Counter-examples: Do they know when NOT to apply?\n\n**Success criteria:** Agent correctly identifies when/how to apply pattern\n\n### Reference Skills (documentation/APIs)\n\n**Examples:** API documentation, command references, library guides\n\n**Test with:**\n- Retrieval scenarios: Can they find the right information?\n- Application scenarios: Can they use what they found correctly?\n- Gap testing: Are common use cases covered?\n\n**Success criteria:** Agent finds and correctly applies reference information\n\n## Common Rationalizations for Skipping Testing\n\n| Excuse | Reality |\n|--------|---------|\n| \"Skill is obviously clear\" | Clear to you ‚â† clear to other agents. Test it. |\n| \"It's just a reference\" | References can have gaps, unclear sections. Test retrieval. |\n| \"Testing is overkill\" | Untested skills have issues. Always. 15 min testing saves hours. |\n| \"I'll test if problems emerge\" | Problems = agents can't use skill. Test BEFORE deploying. |\n| \"Too tedious to test\" | Testing is less tedious than debugging bad skill in production. |\n| \"I'm confident it's good\" | Overconfidence guarantees issues. Test anyway. |\n| \"Academic review is enough\" | Reading ‚â† using. Test application scenarios. |\n| \"No time to test\" | Deploying untested skill wastes more time fixing it later. |\n\n**All of these mean: Test before deploying. No exceptions.**\n\n## Bulletproofing Skills Against Rationalization\n\nSkills that enforce discipline (like TDD) need to resist rationalization. Agents are smart and will find loopholes when under pressure.\n\n**Psychology note:** Understanding WHY persuasion techniques work helps you apply them systematically. See persuasion-principles.md for research foundation (Cialdini, 2021; Meincke et al., 2025) on authority, commitment, scarcity, social proof, and unity principles.\n\n### Close Every Loophole Explicitly\n\nDon't just state the rule - forbid specific workarounds:\n\n<Bad>\n```markdown\nWrite code before test? Delete it.\n```\n</Bad>\n\n<Good>\n```markdown\nWrite code before test? Delete it. Start over.\n\n**No exceptions:**\n- Don't keep it as \"reference\"\n- Don't \"adapt\" it while writing tests\n- Don't look at it\n- Delete means delete\n```\n</Good>\n\n### Address \"Spirit vs Letter\" Arguments\n\nAdd foundational principle early:\n\n```markdown\n**Violating the letter of the rules is violating the spirit of the rules.**\n```\n\nThis cuts off entire class of \"I'm following the spirit\" rationalizations.\n\n### Build Rationalization Table\n\nCapture rationalizations from baseline testing (see Testing section below). Every excuse agents make goes in the table:\n\n```markdown\n| Excuse | Reality |\n|--------|---------|\n| \"Too simple to test\" | Simple code breaks. Test takes 30 seconds. |\n| \"I'll test after\" | Tests passing immediately prove nothing. |\n| \"Tests after achieve same goals\" | Tests-after = \"what does this do?\" Tests-first = \"what should this do?\" |\n```\n\n### Create Red Flags List\n\nMake it easy for agents to self-check when rationalizing:\n\n```markdown\n## Red Flags - STOP and Start Over\n\n- Code before test\n- \"I already manually tested it\"\n- \"Tests after achieve the same purpose\"\n- \"It's about spirit not ritual\"\n- \"This is different because...\"\n\n**All of these mean: Delete code. Start over with TDD.**\n```\n\n### Update CSO for Violation Symptoms\n\nAdd to description: symptoms of when you're ABOUT to violate the rule:\n\n```yaml\ndescription: use when implementing any feature or bugfix, before writing implementation code\n```\n\n## RED-GREEN-REFACTOR for Skills\n\nFollow the TDD cycle:\n\n### RED: Write Failing Test (Baseline)\n\nRun pressure scenario with subagent WITHOUT the skill. Document exact behavior:\n- What choices did they make?\n- What rationalizations did they use (verbatim)?\n- Which pressures triggered violations?\n\nThis is \"watch the test fail\" - you must see what agents naturally do before writing the skill.\n\n### GREEN: Write Minimal Skill\n\nWrite skill that addresses those specific rationalizations. Don't add extra content for hypothetical cases.\n\nRun same scenarios WITH skill. Agent should now comply.\n\n### REFACTOR: Close Loopholes\n\nAgent found new rationalization? Add explicit counter. Re-test until bulletproof.\n\n**Testing methodology:** See @testing-skills-with-subagents.md for the complete testing methodology:\n- How to write pressure scenarios\n- Pressure types (time, sunk cost, authority, exhaustion)\n- Plugging holes systematically\n- Meta-testing techniques\n\n## Anti-Patterns\n\n### ‚ùå Narrative Example\n\"In session 2025-10-03, we found empty projectDir caused...\"\n**Why bad:** Too specific, not reusable\n\n### ‚ùå Multi-Language Dilution\nexample-js.js, example-py.py, example-go.go\n**Why bad:** Mediocre quality, maintenance burden\n\n### ‚ùå Code in Flowcharts\n```dot\nstep1 [label=\"import fs\"];\nstep2 [label=\"read file\"];\n```\n**Why bad:** Can't copy-paste, hard to read\n\n### ‚ùå Generic Labels\nhelper1, helper2, step3, pattern4\n**Why bad:** Labels should have semantic meaning\n\n## STOP: Before Moving to Next Skill\n\n**After writing ANY skill, you MUST STOP and complete the deployment process.**\n\n**Do NOT:**\n- Create multiple skills in batch without testing each\n- Move to next skill before current one is verified\n- Skip testing because \"batching is more efficient\"\n\n**The deployment checklist below is MANDATORY for EACH skill.**\n\nDeploying untested skills = deploying untested code. It's a violation of quality standards.\n\n## Skill Creation Checklist (TDD Adapted)\n\n**IMPORTANT: Use TodoWrite to create todos for EACH checklist item below.**\n\n**RED Phase - Write Failing Test:**\n- [ ] Create pressure scenarios (3+ combined pressures for discipline skills)\n- [ ] Run scenarios WITHOUT skill - document baseline behavior verbatim\n- [ ] Identify patterns in rationalizations/failures\n\n**GREEN Phase - Write Minimal Skill:**\n- [ ] Name uses only letters, numbers, hyphens (no parentheses/special chars)\n- [ ] YAML frontmatter with only name and description (max 1024 chars)\n- [ ] Description starts with \"Use when...\" and includes specific triggers/symptoms\n- [ ] Description written in third person\n- [ ] Keywords throughout for search (errors, symptoms, tools)\n- [ ] Clear overview with core principle\n- [ ] Address specific baseline failures identified in RED\n- [ ] Code inline OR link to separate file\n- [ ] One excellent example (not multi-language)\n- [ ] Run scenarios WITH skill - verify agents now comply\n\n**REFACTOR Phase - Close Loopholes:**\n- [ ] Identify NEW rationalizations from testing\n- [ ] Add explicit counters (if discipline skill)\n- [ ] Build rationalization table from all test iterations\n- [ ] Create red flags list\n- [ ] Re-test until bulletproof\n\n**Quality Checks:**\n- [ ] Small flowchart only if decision non-obvious\n- [ ] Quick reference table\n- [ ] Common mistakes section\n- [ ] No narrative storytelling\n- [ ] Supporting files only for tools or heavy reference\n\n**Deployment:**\n- [ ] Commit skill to git and push to your fork (if configured)\n- [ ] Consider contributing back via PR (if broadly useful)\n\n## Discovery Workflow\n\nHow future Claude finds your skill:\n\n1. **Encounters problem** (\"tests are flaky\")\n3. **Finds SKILL** (description matches)\n4. **Scans overview** (is this relevant?)\n5. **Reads patterns** (quick reference table)\n6. **Loads example** (only when implementing)\n\n**Optimize for this flow** - put searchable terms early and often.\n\n## The Bottom Line\n\n**Creating skills IS TDD for process documentation.**\n\nSame Iron Law: No skill without failing test first.\nSame cycle: RED (baseline) ‚Üí GREEN (write skill) ‚Üí REFACTOR (close loopholes).\nSame benefits: Better quality, fewer surprises, bulletproof results.\n\nIf you follow TDD for code, follow it for skills. It's the same discipline applied to documentation."
    }
  ]
}